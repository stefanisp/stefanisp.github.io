[{"id":0,"href":"/docs/c-course/basic/","title":"Básico","section":"Curso: Introdução à Programação com a Linguagem C","content":""},{"id":1,"href":"/docs/c-course/","title":"Curso: Introdução à Programação com a Linguagem C","section":"Docs","content":" Introdução à Programação com a Linguagem C # Programação é o método que utilizamos para criar sistemas computacionais, como jogos, websites, aplicativos de celular, e todos os sistemas de computador que encontramos em bancos, farmácias e supermercados.\nProgramar é a tarefa de se comunicar com o computador através da escrita de uma sequencia de tarefas (instruções) que desejamos que seja executada. Toda comunicação requer uma linguagem comum entre as entidades que se comunicam, neste caso entre o humano (o programador) e o computador. Dessa forma, aprenderemos uma linguagem de programação para nos comunicarmos com a computador.\nA linguagem C # C é uma linguagem de propósito geral. Isso quer dizer que ela pode ser utilizada para escrever programas para várias àreas diferentes. Sua linguagem segue um padrão procedural, permitindo a decomposição de problemas grande e complexos em procedimentos (módulos) separados e mais simples.\nComo toda linguagem de programação, C possui um conjuto de palavras reservadas que são utilizadas para a criação das instruções que comporão um programa. A palavras reservadas em C são:\nConfigurando o ambiente de programação # (Atividade desenvolvida no laboratório) - (será detalhado na página em breve)\nPrimeiro programa em C # Agora vamos executar o primeiro código em C. Ao ser executado, o programa irá imprimir na tela a mensagem \u0026ldquo;Olá, mundo lindo!\u0026rdquo;. Digite o seguinte texto (código-fonte) em um arquivo chamado primeiro_programa.c:\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;Olá, mundo lindo!\u0026quot;); return 0; } Vamos entender:\nVocê criará muitos arquivos com códigos em C daqui pra frente, e existem regras para a nomeação desses arquivos. As regras são:\nO arquivo deve ter a extensão .c. Não podem haver espaços no nome do arquivo. Por exemplo: \u0026ldquo;primeiro programa.c\u0026rdquo;. A maioria dos arquivos começará com instruções #include \u0026lt; \u0026hellip; \u0026gt;, chamadas de cabeçalho do programa. #include é uma instrução utilizada para adicionarmos procedimentos (funções) que já foram programados previamente. No exemplo, estamos adicionando ao nosso programa um arquivo presente no compilador C que foi instalado na sua máquina. O arquivo stdio.h contém código C (entederemos mais à frente a extensão .h) com procedimentos que permitem a entrada e saída de textos na tela.\nint main (){ \u0026hellip; } é uma sintaxe mandatória que identifica o ponto inicial de execução do seu código. Quando executado, o seu programa começará a executar as instruções criadas dentro desse bloco delimitado pelas chaves { }. Entenderemos melhor essa estrutura quando estudarmos a declaração de funções em C. No exemplo, temos duas instruções dentro do bloco main:\nprintf é uma função definida no arquivo stdio.h para impressão de textos na tela. O texto que será impresso deve ser colocado entre aspas. return é uma palavra reservada utilizada para finalizar a execução de um bloco de código. Mais um exemplo de código:\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;Programação requer prática. \\n Pratique!\u0026quot;); printf(\u0026quot;\\n Pratique!\u0026quot;); return 0; } Neste exemplo acrescentamos ao texto dentro do printf uma sequência de escape. Perceba que tem um \\n no meio do texto do primeiro printf, e no inicio do texto do segundo printf. Sequencias de escape são utilizados em textos para a inserção de caracteres especiais. O \\n representa quebra de linha, como um enter do teclado. Dessa forma, a saída do programa será:\nProgramação requer prática. Pratique! Pratique! Básico da Linguagem C # Estudaremos primeiro o que considero funcionalidades básicas da linguagem.\nComentários # Além de instruções, o seu programa pode conter comentários para auxiliar o entendimento do código. É uma boa prática de programação documentar o seu código com comentários informativos e instrutivos para auxiliar a manutenção do código. Existem dois tipos de comentários em C: de linha e de bloco. Ambos são ignorados pelo compilador na criação do arquivo executável do programa.\nO comentário de linha se inicia com duas barras (//) e seu escopo finaliza ao final de uma linha:\n//Este é um comentário de linha. //Este é outro comentário de linha. O comentário de bloco é delimitado pelos símbolos /* para abertura e */ para fechamento do bloco. Todas as linhas dentro do bloco fazem parte do mesmo comentário.\n/* Este é um comentário de bloco */ /* Este também é um comentário de bloco */ Ponto e vírgula # C utiliza ponto e vírgula como delimitador de instruções. É a forma que o compilador utiliza para saber como ler e separar as instruções no código. Note que, no nosso exemplo, temos duas instruções que são finalizadas com ponto e vírgula:\nprintf(\u0026quot;Olá mundo lindo!\u0026quot;); return 0; Algumas instruções já possuem o próprio delimitador, e não precisam de ponto e vírgula. Será fácil identificá-las quando você avançar no curso.\nVariáveis # Os dados que criamos e manipulamos em nosso programa precisam ser armazenados na memória do computador para que possam ser referenciados e utilizados no código. Linguagens de programação utilizam variáveis para este propósito. Em C, uma variável deve ser declarada no código com o seu tipo e um nome.\n//Sintaxe de instrução para criação de variável tipo nome; Os tipos são convenções definidas na linguagem, para que o compilador saiba a quantidade de memória máxima que será reservada para armazenar dados na variável. Os tipos básicos em C são:\nTipo Tamanho Descrição char 8 bits Armazena códigos correspondentes a um caracter da tabela ASCII. int 16 bits ou 32 bits Armazena números inteiros (positivos e negativos). float 32 bits Armazena números fracionários, com precisão de até sete dígitos. double 64 bits Armazena números fracionários, com precisão de até 15 dígitos. Estudaremos mais sobre os tipos de variáveis e como podem ser modificados ao longo do curso.\nExemplo de declaração de variáveis de cada tipo:\nint x; float y; char z; double k; Variáveis do mesmo tipo podem ser declaradas na mesma linha, separadas por vírgula. Exemplo:\nint x, w, q; //declaração de três variáveis do tipo int O nome da variável pode ser utilizado em diferentes partes do código para acessarmos o conteúdo presente na posição de memória correspondente.\nExistem regras para a nomeação das variáveis. São estas:\nPodem utilizar letras maiúsculas, letras minúsculas, números e o caracter sublinhado; Não podem ser iniciados com números; Não podem ser idênticos às palavras reservadas da linguagem. Exemplos de nomes válidos e inválidos:\n//Exemplos de nomes válidos int nomeValido01; float nome_valido_02; char _nomeValido_03; //Exemplos de nomes inválidos int int; int 2nome_invalido; Operador de atribuição # Como na matemática, atribuimos valor às variáveis com o símbolo de atribuição =. Podemos atribuir valor à uma variável em sua declaração, ou em outras partes do código após a sua declaração. Exemplos:\n//Atribuição de valores em conjunto com a declaração da variável int x = 10; //leia-se: x recebe o valor 10 float y = 10.123; char z = 'a'; //Atribuição de valores após a criação das variáveis x = 12; z = 15.0; z = 'b'; Podemos atribuir valor à mesma variável quantas vezes quisermos no mesmo programa, o valor da variável sempre é apagado da memória e substituido pelo valor mais recente que for atribuido.\nUma variável também pode receber o valor de outra variável na atribuição, por exemplo:\nint x, y; x = 10; y = x; // Atribuímos o valor 10 da variável x à variável y. Equivale à y = 10; Podemos também concatenar as atribuições de valores, por exemplo:\n//Atribuição na declaração concatenada de variáveis do mesmo tipo int x = 1, y = 2, z = 3; //Atribuição do mesmo valor à mais de uma variável. x = y = z = 4; Ao tipo char podem ser atribuídos o caracter envolto em aspas simples, como nos exemplos acima, ou o número inteiro correspondente da tabela ASCII. Exemplo:\nz = 'c'; z = 99; //Na tabela ASCII, 99 é o valor decimal do caracter c. Lendo e imprimindo valores de variáveis # Nós já aprendemos a imprimir textos na tela com o comando printf(). Também utilizamos o printf() para imprimir valores de variáveis. Para isso, o comando requer a sinalização do tipo de variável que será impressa. A linguagem C utiliza uma sequência de caracteres para fazer essa sinalização, e cada tipo de variável tem um sinalizador diferente. Exemplos de sequências são:\nCaracteres Tipo de variável %d int %f float %c char Exemplos de comandos com impressão de variáveis:\nint var_int = 10; float var_float = 10.5; char var_char = 'A'; printf(\u0026quot;%d\u0026quot;, var_int); printf(\u0026quot;%f\u0026quot;, var_float); printf(\u0026quot;%c\u0026quot;, var_char); Podemos concatenar valores de variáveis com textos que serão impressos na tela. Por exemplo:\nint var_int = 10; float var_float = 10.5; char var_char = 'A'; printf(\u0026quot;O valor da variável tipo int é: %d.\u0026quot;, var_int); printf(\u0026quot;O valor %f pertence à variável do tipo float.\u0026quot;, var_float); printf(\u0026quot;%c é o conteúdo da variável var_char.\u0026quot;, var_char); printf(\u0026quot;Os valores das variáveis são: %d, %f, %c\u0026quot;, var_int, var_float, var_char); Para permitir que o usuário insira valores no programa, podemos ler informações digitadas no teclado com o comando scanf(). Seguem exemplos de utilização:\nint var_int; float var_float; char var_char; printf(\u0026quot;Digite um valor inteiro:\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;var_int); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026quot;Digite um valor fracionado:\u0026quot;); scanf(\u0026quot;%f\u0026quot;, \u0026amp;var_float); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026quot;Digite um caractere:\u0026quot;); scanf(\u0026quot;%c\u0026quot;, \u0026amp;var_char); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026quot;Os valores digitados são: %d, %f, %c\u0026quot;, var_int, var_float, var_char); Falaremos mais sobre o comando scanf() ao longo do curso.\nOperadores aritméticos binários # Variáveis numéricas podem compor expressões aritméticas no código. Os operadores aplicados em C são:\nOperador Descrição Exemplo + soma z = x + y; - subtração z = x - y; * multiplicação z = x + y; / divisão z = x / y; % resto da divisão z = x % y; Da mesma forma que na matemática, a multiplicação e a divisão têm precedência à soma e à subtração. Para entender a execução de expressões com operadores de mesma precedência, saiba que a linguagem executará as operações da esquerda para a direita. Os parênteses também podem ser utilizados para organização de precedência na execução.\nOs operadores exemplificados acima são binários. Isto quer dizer que requerem dois elementos para realizar a operação. Nos exemplos da tabela temos x e y. Outros exemplos válidos são:\ny = 1 + 2; x = x + x; x = x - 1; z = 10 * y; Operadores aritméticos unários # Os operadores de adição e subtração também podem ser utilizados com uma única variável para incremento ou decremento do valor da variável. Neste caso, dizemos que o operador é unário. A sintaxe é diferente, pois duplicamos o operador. Veja os exemplos:\nx++; // equivale a x = x + 1; y--; // equivale a y = y - 1; Nos exemplos acima, o novo valor da variável será acessível a partir da próxima linha de código. Existe ainda a possibilidade de anteciparmos o acesso ao novo valor para a mesma linha da instrução que altera a variável. Para isso, mudamos a ordem dos operadores para:\n++x; // também incrementa 1 ao valor de x; --y; // também decrementa 1 ao valor de y; O operador de subtração também pode ser utilizado de forma unária para a declaração de números negativos. Exemplo:\nx = -1; y = - 10; Operadores relacionais # Operadores relacionais são utilizados para formar expressões que comparam dois ou mais elementos, para obter o resultado verdadeiro ou falso. Os operadores relacionais em C são:\nOperador Descrição Exemplo \u0026gt; maior que x \u0026gt; y \u0026lt; menor que x \u0026lt; y \u0026gt;= maior ou igual x \u0026gt;= y \u0026lt;= menor ou igual x \u0026lt;= y == igual a x == y != diferente de x != y Em C, as expressões relacionais retornam o valor 0 para informar que a expressão é falsa, e o valor 1 se o resultado da expressão for verdadeiro. Por exemplo:\nint x = 1, y = 2, z; z = x \u0026lt; y; // z recebe o valor 1, pois a expressão (1 é menor que 2) é verdadeira z = x == y; // z recebe o valor 0, pois a expressão (1 é igual a 2) é falsa Operadores lógicos # A lógica boleana é frequentemente utilizada quando programamos. Com a lógica boleana, podemos compor expressões utilizando os operadores binários E e OU, e o operador unário de negação NÃO. Os resultados das expressões serão sempre verdadeiros ou falsos. A semântica dos operadores está resumida nas tabelas abaixo:\nTabela do operador E (Lemos assim: verdadeiro e verdadeiro, é igual a verdadeiro):\nOperando Operador Operando Resultado verdadeiro E verdadeiro verdadeiro verdadeiro E falso falso falso E verdadeiro falso falso E falso falso Tabela do operador OU:\nOperando Operador Operando Resultado verdadeiro OU verdadeiro verdadeiro verdadeiro OU falso verdadeiro falso OU verdadeiro verdadeiro falso OU falso falso A tabela do operador de negação é mais simples. Vamos inverter a ordem do operador, para ler assim: \u0026ldquo;Não verdadeiro, é igual a falso.\u0026rdquo;:\nOperador Operando Resultado NÃO verdadeiro falso NÃO falso verdadeiro Em C, a sintaxe dos operadores boleanos E e OU é, respectivamente, \u0026amp;\u0026amp; e ||. A sintaxe do operador NÃO é o símbolo de exclamação !. Lembremos que, como resultado de expressões, o 0 representa falso e 1 representa verdadeiro. Dessa forma, utilizando a sintaxe em C, as tabelas são:\nOperador \u0026amp;\u0026amp; (E):\nOperando Operador Operando Resultado 1 \u0026amp;\u0026amp; 1 1 1 \u0026amp;\u0026amp; 0 0 0 \u0026amp;\u0026amp; 0 0 0 \u0026amp;\u0026amp; 0 0 Operador || (OU):\nOperando Operador Operando Resultado 1 || 1 1 1 || 0 1 0 || 0 1 0 || 0 0 Operador de negação ! :\nOperador Operando Resultado ! 1 0 ! 0 1 Os operadores lógicos são comumente utilizados em conjunto com outros operadores, por exemplo:\nint x = 1, y = 2, z = 3, w; w = (x \u0026lt; y) \u0026amp;\u0026amp; (x \u0026lt; z); // w recebe o valor 1, como resultado de (1) \u0026amp;\u0026amp; (1) w = (x == y) \u0026amp;\u0026amp; (x \u0026lt; z); // w recebe o valor 0, como resultado de (0) \u0026amp;\u0026amp; (1) w = (x \u0026gt;= y) || (x \u0026lt; z); // w recebe o valor 1, como resultado de (0) || (1) w = (x == y) || (x == z); // w recebe o valor 0, como resultado de (0) || (0) w = !(x == y); // w recebe o valor 1, como resultado de !(0) Comandos condicionais # Podemos adicionar avaliação de condições no código para decidir se um conjunto de instruções deverá ser executado. Condições são expressões cujo resultado será verdadeiro ou falso. Uma vez verdadeiro, o código associado à estrutura condicional será executado. A linguagem C possui três formas de estruturas condicionais: IF-ELSE, SWITCH-CASE, e a estrutura condição ? verdadeiro : falso.\nIF-ELSE # Vamos começar entendo a estrutura de código condicional utilizando apenas o comando IF. A sintaxe do comando é: (Leia-se: SE condição for verdadeira, ENTÃO a instrução seguinte será executada. )\nif (condição) instrução; Por exemplo, considere uma variável x, cujo valor será inserido pelo usuário: (Leia-se: SE x for maior que zero, ENTÃO imprima na tela o texto \u0026ldquo;O valor de x é positivo\u0026rdquo;. )\nif (x \u0026gt; 0) printf(\u0026quot;O valor de x é positivo.\u0026quot;); A sintaxe acima funciona apenas para avaliação condicional de uma única linha de instrução. Para incluir mais linhas de instrução, devemos adicionar um par de chaves {} para iniciar e fechar um bloco de instruções. Dessa forma, todas as instruções dentro do bloco serão executadas apenas se a condição for verdadeira.\nif (condição){ // inicio do bloco de instruções; instrução_01; instrução_02; ... instrução_N; } // final do bloco de instruções; Exemplo:\nif (x \u0026gt; 0){ printf(\u0026quot;O valor de x é positivo.\u0026quot;); x = x + 1; z = x; } Podemos também escrever instruções que deverão ser executadas caso a condição seja falsa. Para isso, complementamos a estrutura do IF com o ELSE. A sintaxe é: (Leia-se: SE condição for verdadeira, ENTÃO instrução_se_condição_verdadeira será executada, SE NÃO, instrução_se_condição_falsa será executada. )\nif (condição) instrução_se_condição_verdadeira; else instrução_se_condição_falsa; Por exemplo: (Leia-se: SE x for maior que zero, ENTÃO imprima na tela o texto \u0026ldquo;O valor de x é positivo\u0026rdquo;, SE NÃO, imprima na tela o texto \u0026ldquo;O valor de x é negativo ou igual a zero\u0026rdquo;. )\nif (x \u0026gt; 0) printf(\u0026quot;O valor de x é positivo.\u0026quot;); else printf(\u0026quot;O valor de x é negativo ou igual a zero.\u0026quot;); Da mesma forma, podemos criar blocos de instruções a partir do else. Por exemplo:\nif (x \u0026gt; 0){ printf(\u0026quot;O valor de x é positivo.\u0026quot;); x = x + 1; z = x; } else { printf(\u0026quot;O valor de x é negativo ou igual a zero.\u0026quot;); w = x; } É possível fazer o aninhamento da estrutura IF-ELSE.\nif (condição_01){ instrução_01; } else if (condição_02){ instrução_02; } else { instrução_03; } Exemplo:\nif (x \u0026gt; 0) { printf(\u0026quot;O valor de x é positivo.\u0026quot;); } else if (x \u0026lt; 0) { printf(\u0026quot;O valor de x é negativo.\u0026quot;); } else{ printf(\u0026quot;O valor de x é zero.\u0026quot;); } Podemos fazer quantos aninhamentos quisermos, por exemplo:\nint lados = 0; printf(\u0026quot;Digite o número de lados do seu polígono:\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. if (lados == 3) { printf(\u0026quot;O polígono é um triângulo.\u0026quot;); } else if (lados == 4) { printf(\u0026quot;O polígono é um quadrilátero.\u0026quot;); } else if (lados == 5) { printf(\u0026quot;O polígono é um pentágono.\u0026quot;); } else if (lados == 6) { printf(\u0026quot;O polígono é um hexágono.\u0026quot;); } else if (lados == 7) { printf(\u0026quot;O polígono é um heptágono.\u0026quot;); } else{ printf(\u0026quot;Valor não identificado.\u0026quot;); } Como temos uma única linha de instrução para cada condição, poderíamos reescrever o código acima dessa forma:\nif (lados == 3) printf(\u0026quot;O polígono é um triângulo.\u0026quot;); else if (lados == 4) printf(\u0026quot;O polígono é um quadrilátero.\u0026quot;); else if (lados == 5) printf(\u0026quot;O polígono é um pentágono.\u0026quot;); else if (lados == 6) printf(\u0026quot;O polígono é um hexágono.\u0026quot;); else if (lados == 7) printf(\u0026quot;O polígono é um heptágono.\u0026quot;); else printf(\u0026quot;Valor não identificado.\u0026quot;); SWITCH-CASE # Blocos de códigos condicionais também podem ser criados com a estrutura SWITCH-CASE. A sintaxe é:\nswitch(variável){ case valor_1: instruções; //podem ser várias linhas de instruções break; case valor_2: instruções; break; ... case valor_m: instruções; break; default: instruções; } Vamos entender:\nA variável dentro do switch() poderá ser do tipo int ou char; O switch é composto por blocos case. Cada bloco case é um teste para saber se o valor da variável é igual ao valor declarado após o nome case (valor_1, no exemplo do primeiro bloco case). Caso seja igual, as instruções pertencentes ao bloco serão executadas. Caso seja diferente, o próximo bloco case será testado. Podemos ler a estrutura acima dessa forma: \u0026ldquo;Caso o valor de variável seja igual a valor_1, execute as instruções do primeiro bloco case, pule todas as outras, e finalize a execução do switch. Caso seja diferente: Execute o mesmo teste para os blocos case sequintes com seus respectivos valores. O último bloco é o default. Se o valor de variável for diferente de todos os valores declarados nos blocos case, as instruções do bloco default serão executadas. Esse bloco é opcional. Perceba que o último comando de cada bloco case é o break. Este comando é o responsável pelo comportamento de \u0026ldquo;pular todos os outros\u0026rdquo; blocos case após encontrar o valor correspondente em um bloco corrente. Vejamos um código exemplo de SWITCH-CASE:\nint lados = 0; printf(\u0026quot;Digite o número de lados do seu polígono:\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. switch(lados){ case 3: printf(\u0026quot;O polígono é um triângulo.\u0026quot;); break; case 4: printf(\u0026quot;O polígono é um quadrilátero.\u0026quot;); break; case 5: printf(\u0026quot;O polígono é um pentágono.\u0026quot;); break; case 6: printf(\u0026quot;O polígono é um hexágono.\u0026quot;); break; case 7: printf(\u0026quot;O polígono é um heptágono.\u0026quot;); break; default: printf(\u0026quot;Valor não identificado.\u0026quot;); } Caso o usuário digite 3, o programa imprimirá na tela apenas O polígono é um triângulo.. Se o usuário digitar um valor que não está declarado em nenhum bloco case, por exemplo, 10, o programa imprimirá: Valor não identificado.\nO comando break é opcional, porém, o SWITCH-CASE funciona de forma diferente se não o utilizarmos. Após encontrar o valor correspondente em um bloco case, todos os outros blocos sequintes serão executados também. Por exemplo, considere o mesmo código sem os comandos break:\nint lados = 0; printf(\u0026quot;Digite o número de lados do seu polígono:\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. switch(lados){ case 3: printf(\u0026quot;O polígono é um triângulo.\u0026quot;); case 4: printf(\u0026quot;O polígono é um quadrilátero.\u0026quot;); case 5: printf(\u0026quot;O polígono é um pentágono.\u0026quot;); case 6: printf(\u0026quot;O polígono é um hexágono.\u0026quot;); case 7: printf(\u0026quot;O polígono é um heptágono.\u0026quot;); default: printf(\u0026quot;Valor não identificado.\u0026quot;); } Neste caso, se o usuário digitar 3, o programa imprimirá na tela: O polígono é um triângulo. O polígono é um quadrilátero. O polígono é um pentágono. O polígono é um hexágono. O polígono é um heptágono. Valor não identificado..\nDa mesma forma, se o usuário digitar 5, o programa imprimirá: O polígono é um pentágono. O polígono é um hexágono. O polígono é um heptágono. Valor não identificado.\nComandos de repetição # As estruturas condicionais estudadas acima executam um bloco de intruções quando uma determinada condição é satisfeita. O bloco é executado apenas uma vez, e o programa prossegue executando as próximas instruções de código, caso existam. As vezes, alguns algorítmos requerem a repetição da execução do mesmo bloco de instruções enquanto uma condição continua sendo satisfeita. Para isso, utilizamos comandos de repetição. A linguagem C possui três formas de estruturas de repetição: FOR, WHILE, e DO WHILE. Veremos a seguir:\nFOR # O comando for permite a repetição de um bloco de instruções enquanto uma condição for satisfeita. A sintaxe do comando for é:\nfor (variável_de_inicialização; condição; incremento){ instruções; } Vamos entender:\nvariável_de_inicialização normalmente contém a declaração e/ou a atribuição de um valor à uma variável que será utilizada como um contador de repetições. condição normalmente contém uma expressão boleana envolvendo a variável_de_inicialização. incremento normalmente contém a adição ou subtração da variável_de_inicialização. O comando for funciona da seguinte forma:\nPrimeiro a instrução em variável_de_inicalização é executada; Em seguida, a condição é testada. Se o resultado for verdadeiro, o bloco de instruções é executado. Ao final da execução do bloco, o comando em incremento é executado. Então, a condição é testada novamente, e o bloco de instruções será executado novamente caso o resultado seja verdadeiro. Executa-se o comando em incremento novamente, e a repetição entre testar condição -\u0026gt; executar bloco de instruções -\u0026gt; executar incremento continua até que a condição não seja satisfeita, ou seja, retorne falso. Um exemplo de código:\nfor (int i = 1; i \u0026lt; 5; i++){ printf(\u0026quot;Repetição %d. \u0026quot;, i); } A saída do código será: Repetição 1. Repetição 2. Repetição 3. Repetição 4.\nOutro exemplo:\nfor (int i = 4; i \u0026gt; 0; i--){ printf(\u0026quot;Repetição %d. \u0026quot;, i); } A saída do código será: Repetição 4. Repetição 3. Repetição 2. Repetição 1.\nExistem variações na estrutura do comando for, mas não trabalharemos com as variações neste momento.\nWHILE # Outra estrutura de repetição é a do comando WHILE. A sintaxe é: (Leia-se: Enquanto condição for verdadeira, execute o bloco de instruções.)\nwhile (condição) { instruções; } Com uma sintaxe mais simples, o while define a condição para que uma sequência de instruções seja executada. O comando testa a condição repetidamente após finalizar a execução de todas as instruções definidas em seu bloco (entre { }). No momento em que a condição não for mais satisfeita, o bloco de instrucões não será mais executado, e a próxima instrução no código será executada, caso exista.\nPodemos conseguir o mesmo efeito do código com a estrutura for anterior, por exemplo:\nint i = 1; while(i \u0026lt; 5) { printf(\u0026quot;Repetição %d. \u0026quot;, i); i++; } A saída do código será: Repetição 1. Repetição 2. Repetição 3. Repetição 4.\nDO WHILE # Uma estrutura semelhante à do WHILE é a DO WHILE. A sintaxe é: (Leia-se: Faça a execução do bloco de instruções, enquanto condição for verdadeira.)\ndo { instruções } while(condição) A diferença desse comando para o while anterior é que o bloco de instruções é executado a primeira vez sem que a condição seja testada. Ao final da primeira execução a condição é avaliada, e se verdadeira, o compilador retorna para o início do bloco novamente, e o mesmo ciclo de repetições acontece até que a condição não seja mais satisfeita.\nExemplo de código:\nint i = 1; do { printf(\u0026quot;Repetição %d. \u0026quot;, i); i++; } while(i \u0026lt; 5) A saída do código também será: Repetição 1. Repetição 2. Repetição 3. Repetição 4.\nComando break # Vimos anteriormente a utilização do comando break em conjunto com o SWITCH-CASE. Porém, o comando break também pode ser utilizado dentro de blocos de intruções de estruturas de repetição. Neste caso, o comando interrompe toda a execução do laço de petição, finalizando a execução da estrutura de repetição ao qual se encontra. Por exemplo:\nint i = 1, j = 0; printf(\u0026quot;Digite um número de 1 a 4: \u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;j); while(i \u0026lt; 5) { if(i == j){ break; } printf(\u0026quot;Repetição %d. \u0026quot;, i); i++; } No código acima, incluímos uma variável j cujo valor será inserido pelo usuário na execução do programa. Incluímos, também, uma condição if dentro do while, que compara o valor da variável i com j. Caso sejam iguais, o comando break é executado, e todo o comando while será finalizado (isso inclui todas as instruções após o bloco do if).\nCaso o usuário digite 3, a saída será: Repetição 1. Repetição 2.\nComando continue # Assim como o comando break, o comando continue pode ser utilizado dentro de blocos de instruções de estruturas de repetição. Porém, ao invés de finalizar toda a execução da estrutura de repetição, o continue finaliza apenas a execução da repetição corrente, e a próxima repetição poderá ser executada (caso a condição continue sendo verdadeira). Por exemplo:\nint i = 1, j = 0; printf(\u0026quot;Digite um número de 1 a 4: \u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;j); while(i \u0026lt; 5) { if(i == j){ i++; continue; } i++; printf(\u0026quot;Repetição %d. \u0026quot;, i); } Neste caso, se o usuário digitar 3, a saída será: Repetição 1. Repetição 2. Repetição 4.\nObserve que, na repetição à qual i assumiu o valor 3, a condição i == j passou a ser verdadeira, e o comando continue foi executado. Sendo assim, as instruções seguintes dentro do bloco while foram puladas, e a condição do while voltou a ser testada para uma nova repetição do seu bloco de instruções. Observe também que incluí o incremento da variável i dentro do bloco if. Consegue me explicar o porquê? Me conte na próxima aula!\nArrays e Matrizes # Até agora trabalhamos com variáveis que comportavam um único valor, por exemplo, um número ou um caractere. A linguagem também permite criarmos variáveis que comportem um conjunto de valores, como uma lista de valores. Começaremos entendendo o que são arrays.\nArrays são variáveis que representam uma lista de valores do mesmo tipo, e podemos acessar cada valor da lista indexando a variável com as posições dos elementos na lista. A sintaxe da declaração é:\ntipo nome_da_variavel[tamanho_da_lista]; Por exemplo:\nint numeros[5]; //uma variável que comporta 5 números inteiros diferentes. Conseguimos atribuir valores ou acessar cada um dos 5 números da variável números através de índices ordenados. Indices em arrays são números inteiros positivos, e começam do valor zero. Na declaração da variável números, temos 5 posições de memória que podem ser acessadas com os índices 0, 1, 2, 3 e 4. Vejamos no código:\nint numeros[5]; numeros[0] = 10; numeros[1] = 11; numeros[2] = 12; numeros[3] = 13; numeros[4] = 14; for(int i = 0; i \u0026lt; 5; i++){ printf(\u0026quot;%d \u0026quot;, numeros[i]); } No código acima, estamos primeiro atribuindo valores à cada uma das posições da variável numeros, e em sequida estamos percorrendo toda a variável com a estrutura de repetição for para imprimir os valores de cada posição na tela. Note que, não existe a posição numeros[5], esta representaria um sexto elemento e extrapolaria o tamanho declarado da variável.\nA saída do programa será: 10 11 12 13 14\nDa mesma forma que fizemos com as variáveis \u0026ldquo;simples\u0026rdquo;, também podemos inicializar a variável em sua declaração. Exemplo:\nint numeros[5] = {10, 11, 12, 13, 14}; for(int i = 0; i \u0026lt; 5; i++){ printf(\u0026quot;%d \u0026quot;, numeros[i]); } Arrays possuem uma única dimensão. Eventualmente precisamos organizar várias listas de valores associados. Para isso, podemos utilizar matrizes. Matrizes são arrays que podem ter várias dimensões, mas neste curso entederemos matrizes com duas dimensões. Como na matemática, podemos chamar a primeira dimensão de linha e a segunda de coluna. A sintaxe da declaração é:\ntipo nome_da_variável[numero_de_linhas][numero_de_colunas]; Exemplo de código:\n// Declaração de uma matriz com duas linhas linhas e três colunas int numeros[2][3]; //uma variável que comporta 6 elementos numeros[0][0] = 10; numeros[0][1] = 11; numeros[0][2] = 12; numeros[1][0] = 13; numeros[1][1] = 14; numeros[1][2] = 15; for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026quot;%d \u0026quot;, numeros[i][j]); } printf(\u0026quot;\\n\u0026quot;); } Perceba que agora precisamos usar indexadores diferentes para cada dimensão, um para acessar a posição da linha e outro para a coluna. O par de indexadores representa o acesso a um único elemento na matriz. Por exemplo, numeros[0][0] acessa o primeiro elemento da matriz, que está na linha zero e coluna zero. Da mesma forma, para percorrer a matriz e imprimir seus elementos precisamos de duas estruturas de repetição, uma para cada dimensão. Cada estrutura define um indexador diferente. No código de exemplo, utilizamos os inteiros i e j para indexar linhas e colunas, respectivamente. Perceba que acrescentei um printf(\u0026quot;\\n\u0026rdquo;) após a finalização do for que percorre as colunas. Dessa forma, após a impressão de cada coluna completa, pularemos uma linha para iniciar a impressão da próxima coluna. A saída do programa será:\n10 11 12 13 14 15 Uma matriz também pode ser inicializada em sua declaração, como fizemos com arrays. A linguagem C permite duas sintaxes diferentes, vejamos o exemplo:\n//Inicalização com todos os elementos em sequência. int numeros_1[2][3] = {10, 11, 12, 13, 14, 15}; //Inicialização com um par de {} interno para cada coluna da matriz int numeros_2[2][3] = {{10, 11, 12}, {13, 14, 15}}; printf(\u0026quot;A matriz numeros_1 é: \\n\u0026quot;); for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026quot;%d \u0026quot;, numeros_1[i][j]); } printf(\u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\nA matriz numeros_2 é: \\n\u0026quot;); for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026quot;%d \u0026quot;, numeros_2[i][j]); } printf(\u0026quot;\\n\u0026quot;); } No exemplo, numeros_1 e numeros_2 são duas matrizes diferentes. Utilizamos uma sintaxe de inicalização diferente para elas, mas as duas foram inicializadas com os mesmos valores. Dessa forma, na impressão da tela as duas matrizes serão iguais.\nStrings # Strings são sequências de caracteres. Em C, uma sequência de caracteres nada mais é do que um array do tipo char. Podemos criar arrays de char da mesma forma que fizemos com os outros tipos anteriormente. Além disso, aos arrays de char também podem ser atribuídos textos diretamente. Vejamos exemplos de declaração de strings:\n// Inicialização com caracteres char string_1[7] = {'S', 't', 'r', 'i', 'n', 'g', '\\n'}; // Inicialização com texto char string_2[7] = \u0026quot;String\u0026quot;; char string_3[7]; string_3 = \u0026quot;String\u0026quot; printf(\u0026quot;%s\u0026quot;, string_1); printf(\u0026quot;%s\u0026quot;, string_2); printf(\u0026quot;%s\u0026quot;, string_3); As strings em C possuem um \\n ao final para representar o final da string. Observe que na declaração de string_1 adicionamos explicitamente o \\n. Na inicialização com texto, isso já é feito pelo compilador de forma implícita. Observe, também, que devemos contabilizar esse último caractere na definição do tamanho do array. Outra novidade é o indicador do tipo de variável no printf, passou a ser %s.\nFunções # Podemos organizar o código em blocos que delimitam um escopo próprio para a realização de uma tarefa específica, e que podem ser reaproveitados em diferentes pontos do código. Fazemos isso através de funções. A sintaxe da declaração de uma função é:\ntipo_de_retorno nome_da_função(tipo_de_parametro_de_entrada nome_parametro_de_entrada){ instruções; return valor_de_retorno; } Vamos entender\nUma função pode receber parâmetros de entrada para utilizar os valores dos parâmetros na realização de alguma tarefa. Para especificar um parâmetro de entrada da função, devemos declarar o seu tipo em tipo_de_parametro_de_entrada seguido do nome que utilizaremos para acessar o parâmetro dentro da função, declarado em nome_parametro_de_entrada.\nParâmetros de entrada são opcionais. Podemos ter vários parâmetros de entrada separados por vírgula, cada um com sua declaração completa (tipo e nome). Uma função pode retornar algum valor, e definimos o tipo do valor na sua declaração em tipo_de_retorno. Neste caso, após realizar sua atividade, a função deverá retornar um valor do tipo declado utilizando a palavra reservada return.\nCaso a função não precise retornar valor algum, utilizamos a palavra void na declaração, e o return será desnecessário. Podemos utilizar return em qualquer ponto do corpo da função. Acessaremos a função através do seu nome, declarado em nome_da_função.\nVejamos exemplos:\n#include \u0026lt;stdio.h\u0026gt; // Função sem parâmetros de entrada e sem retorno. void funcao_1(){ printf(\u0026quot;Execução da função 1.\\n\u0026quot;); } // Função com dois parâmetros de entrada, e que retorna um número inteiro. int funcao_2(int a, int b){ printf(\u0026quot;\\nExecução da função 2, com os valores de entrada %d e %d.\\n\u0026quot;, a, b); return a+b; } int main(){ printf(\u0026quot;Iniciando a execução do programa.\\n\u0026quot;); funcao_1(); //Instanciando funcao_1 int valor = funcao_2(1, 2); //Instanciando funcao_2 printf(\u0026quot;A soma de 1 e 2 é %d\u0026quot;, valor); //Instanciando funcao_2 novamente printf(\u0026quot;A soma de 10 e 11 é %d\u0026quot;, funcao_2(10, 11)); return 0; } Vamos entender:\nO códido começa a ser executado no escopo principal main(), e toda vez que há a chamada de uma função, o fluxo de execução \u0026ldquo;pula\u0026rdquo; para o escopo da função e executa todo o código da função. Ao finalizar a execução da função, o fluxo de execução do programa retorna para o escopo main() e a próxima linha de código após a chamada da função é executada.\nAs funções são declaradas antes de serem chamadas. Perceba que elas foram declaradas antes do inicio do escopo main().\nfuncao_1() é a forma chamamos funcao_1 para ser executada.\nA funcao_2 possui dois parâmetros de entrada, dessa forma precisamos passar valores de tipos equivalentes na sua chamada. Na chamada funcao_2(1, 2) passamos os valores 1 e 2, que serão atribuídos aos parâmetros a e b da função.\nNas chamadas de funcao_2 do código acima, passamos valores diretamente para serem atribuídos aos parâmetros de entrada da função. Poderíamos, também, passar variáveis como parâmetros. Neste caso, os valores atribuídos previamente às variáveis serão copiados para os parâmetros de entrada da função. Vejamos um exemplo:\n#include \u0026lt;stdio.h\u0026gt; // Função com um parâmetro de entrada, e que retorna um número fracionado. float funcao_3(int num){ float resultado; if(num == 0){ return 0; } resultado = 10 / num; return resultado; } int main(){ int numero = 10; float resultado = funcao_3(numero); printf(\u0026quot;A função 3 teve como retorno o valor: %f\u0026quot;, resultado ); } No exemplo, a variável numero foi inicalizada com o valor 10, e passamos a variável como parâmetro da chamada de funcao_3. Isso quer dizer que o valor 10 será copiado para o parâmetro de entrada num da função.\nPonteiros # Mais sobre variáveis # Escopo de variáveis # Modificadores de variáveis # Constantes # Conversão de tipos # Definição de tipos # "},{"id":2,"href":"/docs/c-course/intermediate/","title":"2023 - Atividades","section":"Curso: Introdução à Programação com a Linguagem C","content":" Atividades # "},{"id":3,"href":"/docs/python/","title":"Curso: Programação com Python","section":"Docs","content":" Programação com Python # Neste curso utilizaremos a linguagem de programação Python para nos comunicarmos com o computador.\nA linguagem Python # Assim como C, Python é uma linguagem de propósito geral. Isso quer dizer que ela pode ser utilizada para escrever programas para várias àreas diferentes. Da mesma forma, Python permite a decomposição de programas em módulos separados que podem ser reutilizados.\nÉ uma linguagem interpretada, \u0026hellip;variáveis não precisam ser declaradas\n\u0026hellip; Mais informações no site: https://www.python.org\nComo toda linguagem de programação, Python possui um conjuto de palavras reservadas que são utilizadas para a criação das instruções que comporão um programa. A palavras reservadas em Python são:\nConfigurando o ambiente de programação # (Atividade desenvolvida no laboratório) - (será detalhado na página em breve)\nUntil there, see https://www.python.org/downloads/.\nPrimeiro programa em Python # Agora vamos executar o primeiro código em Python. Ao ser executado, o programa irá imprimir na tela a mensagem \u0026ldquo;Olá, mundo lindo!\u0026rdquo;. Digite o seguinte texto (código-fonte) em um arquivo chamado primeiro_programa.py:\nprint(\u0026quot;Olá, mundo lindo!\u0026quot;) Vamos entender:\nVocê criará muitos arquivos com códigos em Python daqui pra frente, e existem regras para a nomeação desses arquivos. As regras são:\nO arquivo deve ter a extensão .py. O nome do arquivo pode conter qualquer caractere alfa-numérico (A-z e 0-9) e o caractere sublinhado (_). Deve começar com uma letra ou o sublinhado. Não podem haver espaços no nome do arquivo. Por exemplo: \u0026ldquo;primeiro programa.py\u0026rdquo;. O interpretador Python que está instalado na sua máquina possui procedimentos (funções) que já foram programados previamente e podem ser reutilizados. Por exemplo, print é uma função definida no arquivo \u0026hellip;\u0026hellip;. para impressão de textos na tela. O texto que será impresso deve ser colocado entre aspas.\nEm sala, veremos que este código também pode ser executado no modo interativo, sem a necessidade da criação de um arquivo. No modo interativo, as linhas de código são executadas à medida que vamos escrevendo em um terminal interativo, a partir da chamada ao interpretador python. Por exemplo, ao digitar python3.11 no terminal do computador, estamos iniciando o modo interativo do interpretador python (versão 3.11), e a saída será:\nApós digitarmos o comando print(\u0026ldquo;Olá, mundo lindo!\u0026rdquo;) e apertarmos enter, podemos ver a saída em tela, e o interpretador continua ativo esperando a próxima instrução.\nEste modo é útil para testes rápidos, mas volátil, ou seja, todo o código é apagado da memória do computador quando saímos do modo interativo. Uma forma de sairmos é digitar exit(), que é uma função presente no interpretador para finalizar a execução de um programa.\nBásico da Linguagem Python # Estudaremos primeiro o que considero funcionalidades básicas da linguagem.\nComentários # Além de instruções, o seu programa pode conter comentários para auxiliar o entendimento do código. É uma boa prática de programação documentar o seu código com comentários informativos e instrutivos para auxiliar a manutenção do código. Existem dois tipos de comentários em C: de linha e de bloco. Ambos são ignorados pelo compilador na criação do arquivo executável do programa.\nO comentário de linha se inicia com duas barras (//) e seu escopo finaliza ao final de uma linha:\n//Este é um comentário de linha. //Este é outro comentário de linha. O comentário de bloco é delimitado pelos símbolos /* para abertura e */ para fechamento do bloco. Todas as linhas dentro do bloco fazem parte do mesmo comentário.\n/* Este é um comentário de bloco */ /* Este também é um comentário de bloco */ Ponto e vírgula # C utiliza ponto e vírgula como delimitador de instruções. É a forma que o compilador utiliza para saber como ler e separar as instruções no código. Note que, no nosso exemplo, temos duas instruções que são finalizadas com ponto e vírgula:\nprintf(\u0026quot;Olá mundo lindo!\u0026quot;); return 0; Algumas instruções já possuem o próprio delimitador, e não precisam de ponto e vírgula. Será fácil identificá-las quando você avançar no curso.\nVariáveis # Os dados que criamos e manipulamos em nosso programa precisam ser armazenados na memória do computador para que possam ser referenciados e utilizados no código. Linguagens de programação utilizam variáveis para este propósito. Em C, uma variável deve ser declarada no código com o seu tipo e um nome.\n//Sintaxe de instrução para criação de variável tipo nome; Os tipos são convenções definidas na linguagem, para que o compilador saiba a quantidade de memória máxima que será reservada para armazenar dados na variável. Os tipos básicos em C são:\nTipo Tamanho Descrição char 8 bits Armazena códigos correspondentes a um caracter da tabela ASCII. int 16 bits ou 32 bits Armazena números inteiros (positivos e negativos). float 32 bits Armazena números fracionários, com precisão de até sete dígitos. double 64 bits Armazena números fracionários, com precisão de até 15 dígitos. Estudaremos mais sobre os tipos de variáveis e como podem ser modificados ao longo do curso.\nExemplo de declaração de variáveis de cada tipo:\nint x; float y; char z; double k; Variáveis do mesmo tipo podem ser declaradas na mesma linha, separadas por vírgula. Exemplo:\nint x, w, q; //declaração de três variáveis do tipo int O nome da variável pode ser utilizado em diferentes partes do código para acessarmos o conteúdo presente na posição de memória correspondente.\nExistem regras para a nomeação das variáveis. São estas:\nPodem utilizar letras maiúsculas, letras minúsculas, números e o caracter sublinhado; Não podem ser iniciados com números; Não podem ser idênticos às palavras reservadas da linguagem. Exemplos de nomes válidos e inválidos:\n//Exemplos de nomes válidos int nomeValido01; float nome_valido_02; char _nomeValido_03; //Exemplos de nomes inválidos int int; int 2nome_invalido; Operador de atribuição # Como na matemática, atribuimos valor às variáveis com o símbolo de atribuição =. Podemos atribuir valor à uma variável em sua declaração, ou em outras partes do código após a sua declaração. Exemplos:\n//Atribuição de valores em conjunto com a declaração da variável int x = 10; //leia-se: x recebe o valor 10 float y = 10.123; char z = 'a'; //Atribuição de valores após a criação das variáveis x = 12; z = 15.0; z = 'b'; Podemos atribuir valor à mesma variável quantas vezes quisermos no mesmo programa, o valor da variável sempre é apagado da memória e substituido pelo valor mais recente que for atribuido.\nUma variável também pode receber o valor de outra variável na atribuição, por exemplo:\nint x, y; x = 10; y = x; // Atribuímos o valor 10 da variável x à variável y. Equivale à y = 10; Podemos também concatenar as atribuições de valores, por exemplo:\n//Atribuição na declaração concatenada de variáveis do mesmo tipo int x = 1, y = 2, z = 3; //Atribuição do mesmo valor à mais de uma variável. x = y = z = 4; Ao tipo char podem ser atribuídos o caracter envolto em aspas simples, como nos exemplos acima, ou o número inteiro correspondente da tabela ASCII. Exemplo:\nz = 'c'; z = 99; //Na tabela ASCII, 99 é o valor decimal do caracter c. Lendo e imprimindo valores de variáveis # (TODO)\nOperadores aritméticos binários # Variáveis numéricas podem compor expressões aritméticas no código. Os operadores aplicados em C são:\nOperador Descrição Exemplo + soma z = x + y; - subtração z = x - y; * multiplicação z = x + y; / divisão z = x / y; % resto da divisão z = x % y; Da mesma forma que na matemática, a multiplicação e a divisão têm precedência à soma e à subtração. Para entender a execução de expressões com operadores de mesma precedência, saiba que a linguagem executará as operações da esquerda para a direita. Os parênteses também podem ser utilizados para organização de precedência na execução.\nOs operadores exemplificados acima são binários. Isto quer dizer que requerem dois elementos para realizar a operação. Nos exemplos da tabela temos x e y. Outros exemplos válidos são:\ny = 1 + 2; x = x + x; x = x - 1; z = 10 * y; Operadores aritméticos unários # Os operadores de adição e subtração também podem ser utilizados com uma única variável para incremento ou decremento do valor da variável. Neste caso, dizemos que o operador é unário. A sintaxe é diferente, pois duplicamos o operador. Veja os exemplos:\nx++; // equivale a x = x + 1; y--; // equivale a y = y - 1; Nos exemplos acima, o novo valor da variável será acessível a partir da próxima linha de código. Existe ainda a possibilidade de anteciparmos o acesso ao novo valor para a mesma linha da instrução que altera a variável. Para isso, mudamos a ordem dos operadores para:\n++x; // também incrementa 1 ao valor de x; --y; // também decrementa 1 ao valor de y; O operador de subtração também pode ser utilizado de forma unária para a declaração de números negativos. Exemplo:\nx = -1; y = - 10; Operadores relacionais # Operadores relacionais são utilizados para formar expressões que comparam dois ou mais elementos, para obter o resultado verdadeiro ou falso. Os operadores relacionais em C são:\nOperador Descrição Exemplo \u0026gt; maior que x \u0026gt; y \u0026lt; menor que x \u0026lt; y \u0026gt;= maior ou igual x \u0026gt;= y \u0026lt;= menor ou igual x \u0026lt;= y == igual a x == y != diferente de x != y Em C, as expressões relacionais retornam o valor 0 para informar que a expressão é falsa, e o valor 1 se o resultado da expressão for verdadeiro. Por exemplo:\nint x = 1, y = 2, z; z = x \u0026lt; y; // z recebe o valor 1, pois a expressão (1 é menor que 2) é verdadeira z = x == y; // z recebe o valor 0, pois a expressão (1 é igual a 2) é falsa Operadores lógicos # A lógica boleana é frequentemente utilizada quando programamos. Com a lógica boleana, podemos compor expressões utilizando os operadores binários E e OU, e o operador unário de negação NÃO. Os resultados das expressões serão sempre verdadeiros ou falsos. A semântica dos operadores está resumida nas tabelas abaixo:\nTabela do operador E (Lemos assim: verdadeiro e verdadeiro, é igual a verdadeiro):\nOperando Operador Operando Resultado verdadeiro E verdadeiro verdadeiro verdadeiro E falso falso falso E verdadeiro falso falso E falso falso Tabela do operador OU:\nOperando Operador Operando Resultado verdadeiro OU verdadeiro verdadeiro verdadeiro OU falso verdadeiro falso OU verdadeiro verdadeiro falso OU falso falso A tabela do operador de negação é mais simples. Vamos inverter a ordem do operador, para ler assim: \u0026ldquo;Não verdadeiro, é igual a falso.\u0026rdquo;:\nOperador Operando Resultado NÃO verdadeiro falso NÃO falso verdadeiro Em C, a sintaxe dos operadores boleanos E e OU é, respectivamente, \u0026amp;\u0026amp; e ||. A sintaxe do operador NÃO é o símbolo de exclamação !. Lembremos que, como resultado de expressões, o 0 representa falso e 1 representa verdadeiro. Dessa forma, utilizando a sintaxe em C, as tabelas são:\nOperador \u0026amp;\u0026amp; (E):\nOperando Operador Operando Resultado 1 \u0026amp;\u0026amp; 1 1 1 \u0026amp;\u0026amp; 0 0 0 \u0026amp;\u0026amp; 0 0 0 \u0026amp;\u0026amp; 0 0 Operador || (OU):\nOperando Operador Operando Resultado 1 || 1 1 1 || 0 1 0 || 0 1 0 || 0 0 Operador de negação ! :\nOperador Operando Resultado ! 1 0 ! 0 1 Os operadores lógicos são comumente utilizados em conjunto com outros operadores, por exemplo:\nint x = 1, y = 2, z = 3, w; w = (x \u0026lt; y) \u0026amp;\u0026amp; (x \u0026lt; z); // w recebe o valor 1, como resultado de (1) \u0026amp;\u0026amp; (1) w = (x == y) \u0026amp;\u0026amp; (x \u0026lt; z); // w recebe o valor 0, como resultado de (0) \u0026amp;\u0026amp; (1) w = (x \u0026gt;= y) || (x \u0026lt; z); // w recebe o valor 1, como resultado de (0) || (1) w = (x == y) || (x == z); // w recebe o valor 0, como resultado de (0) || (0) w = !(x == y); // w recebe o valor 1, como resultado de !(0) Comandos condicionais # Podemos adicionar avaliação de condições no código para decidir se um conjunto de instruções deverá ser executado. Condições são expressões cujo resultado será verdadeiro ou falso. Uma vez verdadeiro, o código associado à estrutura condicional será executado. A linguagem C possui três formas de estruturas condicionais: IF-ELSE, SWITCH-CASE, e a estrutura condição ? verdadeiro : falso.\nIF-ELSE # Vamos começar entendo a estrutura de código condicional utilizando apenas o comando IF. A sintaxe do comando é: (Leia-se: SE condição for verdadeira, ENTÃO a instrução seguinte será executada. )\nif (condição) instrução; Por exemplo: (Leia-se: SE x for maior que zero, ENTÃO imprima na tela o texto \u0026ldquo;O valor de x é positivo\u0026rdquo;. )\nif (x \u0026gt; 0) printf(\u0026quot;O valor de x é positivo.\u0026quot;); A sintaxe acima funciona apenas para avaliação condicional de uma única linha de instrução. Para incluir mais linhas de instrução, devemos adicionar um par de chaves {} para iniciar e fechar um bloco de instruções. Dessa forma, todas as instruções dentro do bloco serão executadas apenas se a condição for verdadeira.\nif (condição){ // inicio do bloco de instruções; instrução_01; instrução_02; ... instrução_N; } // final do bloco de instruções; Exemplo:\nif (x \u0026gt; 0){ printf(\u0026quot;O valor de x é positivo.\u0026quot;); x = x + 1; z = x; } Podemos também escrever instruções que deverão ser executadas caso a condição seja falsa. Para isso, complementamos a estrutura do IF com o ELSE. A sintaxe é: (Leia-se: SE condição for verdadeira, ENTÃO instrução_se_condição_verdadeira será executada, SE NÃO, instrução_se_condição_falsa será executada. )\nif (condição) instrução_se_condição_verdadeira; else instrução_se_condição_falsa; Por exemplo: (Leia-se: SE x for maior que zero, ENTÃO imprima na tela o texto \u0026ldquo;O valor de x é positivo\u0026rdquo;, SE NÃO, imprima na tela o texto \u0026ldquo;O valor de x é negativo ou igual a zero\u0026rdquo;. )\nif (x \u0026gt; 0) printf(\u0026quot;O valor de x é positivo.\u0026quot;); else printf(\u0026quot;O valor de x é negativo ou igual a zero.\u0026quot;); Da mesma forma, podemos criar blocos de instruções a partir do else. Por exemplo:\nif (x \u0026gt; 0){ printf(\u0026quot;O valor de x é positivo.\u0026quot;); x = x + 1; z = x; } else { printf(\u0026quot;O valor de x é negativo ou igual a zero.\u0026quot;); w = x; } Mais exemplos ... TODO É possível fazer o aninhamento da estrutura IF-ELSE.\nif (condição_01){ instrução_01; } else if (condição_02){ instrução_02; } else { instrução_03; } Exemplo:\nif (x \u0026gt; 0) { printf(\u0026quot;O valor de x é positivo.\u0026quot;); } else if (x \u0026lt; 0) { printf(\u0026quot;O valor de x é negativo.\u0026quot;); } else{ printf(\u0026quot;O valor de x é zero.\u0026quot;); } Podemos fazer quantos aninhamentos quisermos, por exemplo:\nif (lados == 3) { printf(\u0026quot;O polígono é um triângulo.\u0026quot;); } else if (lados == 4) { printf(\u0026quot;O polígono é um quadrilátero.\u0026quot;); } else if (lados == 5) { printf(\u0026quot;O polígono é um pentágono.\u0026quot;); } else if (lados == 6) { printf(\u0026quot;O polígono é um hexágono.\u0026quot;); } else if (lados == 7) { printf(\u0026quot;O polígono é um heptágono.\u0026quot;); } else{ printf(\u0026quot;Valor não identificado.\u0026quot;); } Como temos uma única linha de instrução para cada condição, poderíamos reescrever o código acima dessa forma:\nif (lados == 3) printf(\u0026quot;O polígono é um triângulo.\u0026quot;); else if (lados == 4) printf(\u0026quot;O polígono é um quadrilátero.\u0026quot;); else if (lados == 5) printf(\u0026quot;O polígono é um pentágono.\u0026quot;); else if (lados == 6) printf(\u0026quot;O polígono é um hexágono.\u0026quot;); else if (lados == 7) printf(\u0026quot;O polígono é um heptágono.\u0026quot;); else printf(\u0026quot;Valor não identificado.\u0026quot;); SWITCH-CASE # Blocos de códigos condicionais também podem ser criados com a estrutura SWITCH-CASE. A sintaxe é:\nswitch(variável){ case valor_1: instruções; //podem ser várias linhas de instruções break; case valor_2: instruções; break; ... case valor_m: instruções; break; default: instruções; } Por exemplo:\nswitch(lados){ case 3: printf(\u0026quot;O polígono é um triângulo.\u0026quot;); break; case 4: printf(\u0026quot;O polígono é um quadrilátero.\u0026quot;); break; case 5: printf(\u0026quot;O polígono é um pentágono.\u0026quot;); break; case 6: printf(\u0026quot;O polígono é um hexágono.\u0026quot;); break; case 7: printf(\u0026quot;O polígono é um heptágono.\u0026quot;); break; default: printf(\u0026quot;Valor não identificado.\u0026quot;); } Vamos entender:\n\u0026hellip;\nCondição ? verdadeiro : falso # Comandos de repetição # FOR # WHILE # DO WHILE # Comandos goto e continue # Funções # Mais sobre variáveis # Escopo de variáveis # Modificadores de variáveis # Constantes # Conversão de tipos # Definição de tipos # Arrays e Matrizes # Strings # Ponteiros # "},{"id":4,"href":"/docs/redes/","title":"Curso: Redes de Computadores","section":"Docs","content":"Em breve.\n"},{"id":5,"href":"/docs/python/expand/","title":"Expand","section":"Curso: Programação com Python","content":" Expand # Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample # Default # {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Expand ↕ Markdown content # Lorem markdownum insigne\u0026hellip; With Custom Label # {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Custom Label ... Markdown content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia. "},{"id":6,"href":"/docs/python/hints/","title":"Hints","section":"Curso: Programação com Python","content":" Hints # Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example # Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa "},{"id":7,"href":"/docs/","title":"Docs","section":"Introduction","content":""}]