[{"id":0,"href":"/docs/01-exerc%C3%ADcios/","title":"Exercícios de Programação","section":"Docs","content":" Exercícios de programação # Lista 01 - Leitura de dados, expressões aritméticas # Escreva um programa que declara três números inteiros e imprime a soma dos números na tela.\nEscreva um programa que lê três números fracionados fornecidos pelo usuário e imprime a soma dos números.\nEscreva um programa que lê dois números inteiros e imprime a soma, a diferença, o produto e a divisão entre esses números.\nEscreva um programa que lê um número inteiro e imprime seu antecessor e seu sucessor.\nEscreva um programa que calcule a área de um quadrado.\nEscreva um programa que calcule a área de um triângulo, sendo fornecidos os valores de sua base e sua altura, utilizando a sequinte fórmula:\nÁrea = (Base * Altura) / 2. Escreva um programa que lê o ano de nascimento de uma pessoa e imprime a idade da pessoa.\nEscreva um programa que calcule o ano de nascimento de uma pessoa a partir de sua idade e do ano atual.\nEscreva um programa que lê o valor de um produto. Aplique um desconto de 25% no valor do produto e imprima uma mensagem para o usuário informando o desconto e o valor final.\nEscreva um programa que lê dois valores inteiros para representar, respectivamente, horas e minutos. Informe quantos minutos se passaram deste o início do dia. Ex:\nValores lidos: 13 horas e 15 minutos Impressão: 795 minutos Escreva um programa que lê uma distância percorrida em km por uma pessoa, e o tempo que levou para percorrê-la (em horas). O programa deve calcular a velocidade média dada pela fórmula:\nVelocidade = Distância / Tempo\nO programa deve imprimir uma mensagem de saída com a velocidade calculada. Ex:\nA velocidade média foi 100 km/h. Escreva um programa que lê os seguintes valores:\nHoras trabalhadas no mês (ht); Valor da hora trabalhada (vh); Percentual de desconto (pd). Calcule e imprima os valores de salário bruto, desconto, e salário líquido, utilizando as sequintes fórmulas:\nSalário bruto: sb = ht * vh; Total do desconto: td = (pd/100) * sb; Salário líquido: sl = sb - td; Lista 02 - Comandos condicionais, expressões relacionais e lógicas # Escreva um programa que lê três números inteiros fornecidos pelo usuário e retorne o maior número dos três.\nEscreva um programa que solicite ao usuário que introduza uma nota, cujo valor pode variar entre 0.0 e 10.0, e imprime o conceito referente a esta nota de acordo com os dados a seguir:\nNota\tConceito Entre 9.0 (inclusive) e 10.0 (inclusive) A Entre 8.0 (inclusive) e 9.0 B Entre 7.0 (inclusive) e 8.0 C Entre 6.0 (inclusive) e 7.0 D Entre 5.0 (inclusive) e 6.0 E Menor do que 5.0 F O programa deve ainda apresentar mensagens de erro correspondentes a entradas fora do intervalo de valores permitido. Em qualquer outro aspecto, você pode assumir que as entradas são corretas.\nEscreva um programa que solicita a introdução n valores inteiros, lê esses números, e apresenta o menor, o maior, e a média dos valores introduzidos. O valor n deve ser o primeiro dado introduzido pelo usuário. Exemplo de interação com o programa:\nQuantos números você irá introduzir? 3 Introduza o próximo número: 5 Introduza o próximo número: -2 Introduza o próximo número: 0 Menor valor introduzido: -2 Maior valor introduzido: 5 Média dos valores introduzidos: 1.0 Escreva um programa que leia 3 valores de ponto flutuante A, B, e C, e ordene-os em ordem decrescente, de modo que o lado A representa o maior dos 3 lados. A seguir, determine o tipo de triângulo que estes três lados formam, com base nos seguintes casos, sempre escrevendo uma mensagem adequada:\n•se A ≥ B+C, apresente a mensagem: NAO FORMA TRIANGULO •se A2 = B2 + C2, apresente a mensagem: TRIANGULO RETANGULO •se A2 \u0026gt; B2 + C2, apresente a mensagem: TRIANGULO OBTUSANGULO •se A2 \u0026lt; B2 + C2, apresente a mensagem: TRIANGULO ACUTANGULO •se os três lados forem iguais, apresente a mensagem: TRIANGULO EQUILATERO •se apenas dois dos lados forem iguais, apresente a mensagem: TRIANGULO ISOSCELES Uma empresa resolveu conceder um aumento de salários a seus funcionários de acordo com os valores abaixo:\nSalário\tPercentual de Reajuste 0.0 a 400.00 15% 400.01 a 800.00 12% 800.01 a 1200.00 10% 1200.01 a 2000.00 7% Acima de 2000.00 4% Leia o salário do funcionário e calcule e mostre o novo salário, bem como o valor de reajuste ganho e o índice reajustado, em percentual.\nFaça um programa para o cálculo de uma folha de pagamento, sabendo que os descontos são do Imposto de Renda, que depende do salário bruto (conforme tabela abaixo) e 3% para o Sindicato e que o FGTS corresponde a 11% do Salário Bruto, mas não é descontado (é a empresa que deposita). O Salário Líquido corresponde ao Salário Bruto menos os descontos. O programa deverá pedir ao usuário o valor da sua hora e a quantidade de horas trabalhadas no mês.\nDesconto do IR: Salário Bruto até 900 (inclusive) - isento Salário Bruto até 1500 (inclusive) - desconto de 5% Salário Bruto até 2500 (inclusive) - desconto de 10% Salário Bruto acima de 2500 - desconto de 20% Imprima na tela as informações, dispostas conforme o exemplo abaixo.( No exemplo, o valor da hora = 5 e quantidade de horas = 220)\nSalário Bruto: (5 * 220) : R$ 1100,00 (-) IR (5%) : R$ 55,00 (-) INSS ( 10%) : R$ 110,00 FGTS (11%) : R$ 121,00 Total de descontos : R$ 165,00 Salário Liquido : R$ 935,00 Lista 03 - Comandos de repetição, expressões relacionais e lógicas # Escreva um programa que imprima o valor do somatório dos números inteiros de 1 a 100.\nEscreva um algoritmo que leia n números inteiros e imprima, para cada número, o seu dobro.\nEscreva um programa que lê um caractere e um numero n, e imprime uma linha com n vezes o caractere lido. Por exemplo, se for lido \u0026lsquo;*\u0026rsquo; e \u0026lsquo;3\u0026rsquo;, o procedimento deve imprimir \u0026lsquo;***\u0026rsquo;. O programa deve verificar se o numero introduzido é valido.\nEscreva um programa que lê dez caracteres e imprime uma linha com cada caractere repetido dez vezes. Cada linha deve comecar com um espaco (i.e., caractere \u0026rsquo; \u0026lsquo;) após a linha anterior.\nUm determinado material radioativo perde metade de sua massa a cada 50 segundos. Dada a massa inicial, em gramas, escreva um programa que determine o tempo necessario para que essa massa se torne menor do que 0.5 gramas. Exiba a massa inicial, a massa final e o tempo calculado em horas, minutos e segundos.\nEscreva um programa que forneça os primeiros n numeros primos, onde n deve ser um valor inteiro introduzido pelo usuario.\nEscreva um programa que solicite ao usuário para introduzir uma série de valores inteiros positivos e lê estes números até que o usuário introduza o valor 0. Então, o programa deve apresentar o menor, o maior e a média dos valores introduzidos (sem levar em consideração o 0). Caso o usuário introduza um número negativo, o programa deve informá-lo que o valor não é válido e não deve levar este valor em consideração. Exemplo de interação com o programa:\nIntroduza uma série de números inteiros positivos terminando a série com zero. Introduza o próximo número: 5 Introduza o próximo número: -2 -2 não é um valor válido. Introduza o próximo número: 1 Introduza o próximo número: 6 Introduza o próximo número: 0 Menor valor introduzido: 1 Maior valor introduzido: 6 Média dos valores introduzidos: 4.0 Imprima os seguintes padrões (O seu algoritmo deve permitir que o padrão possa ser escalado.):\nPadrão 01:\n************ * * * * * * * * ************ Padrão 02:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Padrão 03:\n1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 1 2 3 4 5 6 Padrão 04:\n1 2 3 4 5 6 1 2 3 4 5 1 2 3 4 1 2 3 1 2 1 Padrão 05:\n1 0 1 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 1 Padrão 06:\n1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 Padrão 07:\n1 2 1 2 3 2 1 2 3 4 3 2 1 2 3 4 5 4 3 2 1 2 3 4 5 6 5 4 3 2 1 2 3 4 5 6 Lista 04 - Arrays e matrizes # Escreva um programa que leia um array com 10 números inteiros, calcule e mostre a soma dos quadrados dos elementos do array.\nEscreva um programa que leia dois arrays de 10 números cada, e intercale os elementos desses dois arrays em uma nova variável. Imprima os dois arrays iniciais e o array resultante.\nEscreva um programa que leia um array X, com N elementos, e um valor Z, e informe a posição de Z no array. Caso o valor não seja encontrado, informar a mensagem “O valor Z está fora do conjunto X”.\nEscreva um algoritmo que leia dois arrays de 10 elementos cada e realize a multiplicação dos elementos de mesmo índice, gravando o resultado em um terceiro array. Exiba os três arrays.\nImprima uma matriz 5x5 onde cada elemento deve ser a soma dos índices de sua posição dentro da matriz. Exemplo: matriz[1][1] = 2 matriz[2][3] = 5 matriz[3][5] = 8.\nEscreva um algoritmo que preencha uma matriz 4x3 de números fracionados e depois exiba o elemento armazenado numa linha L e uma coluna C informados pelo usuário.\nLeia duas matrizes A e B, ambas 4 x 4, e crie uma terceira matriz C contendo a soma dos valores de A e B. Ex: elemento (0,0) da matriz C deve conter a soma dos elementos (0,0) de A e B. Ao final, imprima as três matrizes.\nLeia uma matriz 4 x 4 e troque os valores da 1ª linha pelos da 4ª coluna, vice-e-versa. Imprima a matriz obtida.\nDeclare uma matriz 5 x 5. Preencha com 1 a diagonal principal e com 0 os demais elementos. Seu algoritmo deve permitir que a matriz possa ser escalada. Imprima a matriz obtida.\nEscreva um algoritmo para ler valores e armazená-los em uma matriz 5 x 5. O algoritmo deverá calcular a soma dos valores que compõem a diagonal principal e a diagonal secundária da matriz.\nEscreva um programa que leia uma matriz A, de dimensão M x N fornecidas pelo usuário, com M \u0026lt;=20 e N \u0026lt;=30. Imprima a matriz A e a sua matriz transposta (T).\nConsidere uma matriz de distância entre cidades 6 x 6:\nCid_1 Cid_2 Cid_3 Cid_4 Cid_5 Cid_6 Cidade_1 - 63 210 190 - 190 Cidade_2 63 - 160 150 95 - Cidade_3 210 160 - 10 - - Cidade_4 190 150 10 - - - Cidade_5 - 95 - - - 80 Cidade_6 190 - - - 80 - Considere também um vetor de viagem indo de uma cidade a outra. Por exemplo, o vetor abaixo mostra uma viagem da Cidade_3 até Cidade_1, passando por outras cidades com a seguinte rota:\nÍndice\t1\t2\t3\t4\t5\t6 Cidade\t3\t4\t2\t5\t6\t1 Faça um programa que leia a matriz e o vetor e calcule a distância percorrida durante a viagem. Observação: o vetor com a rota da viagem pode variar em tamanho e cidades.\n"},{"id":1,"href":"/docs/04-c++/01-basico/","title":"Módulo 01","section":"CURSO: Informática com C++","content":" PROGRAMAÇÃO COM C++ # Neste curso aprederemos a programar utilizando uma linguagem de programação bem robusta, de alto desempenho, chamada C++.\nC++ é uma linguagem de programação de propósito geral que surgiu como uma extensão da linguagem C, adicionando novos recursos, mas mantendo a compatibilidade com o código já existente em C.\nÉ uma linguagem multiparadigma, o que significa que permite que o código seja escrito de acordo com diferentes paradigmas de programação, ou seja, \u0026ldquo;estilos\u0026rdquo; de como o código é organizado e estruturado. Neste primeiro módulo, focaremos no paradigma procedural (como em C), e no próximo módulo explicarei o paradigma orientado a objetos.\nVamos começar!\nCriando arquivos de implementação C++ # Arquivos de implementação em C++ usam a extensão .cpp. Eles contém o código-fonte com a lógica do programa. Por exemplo:\naula01.cpp Para que o computador possa entender e executar esse arquivo, ele deve ser compilado utilizando-se um compilador da linguagem C++. Nesse processo, o seu código-fonte em C++ será transformado em uma linguagem de máquina, que o computador realmente entende. Estudaremos os compiladores em módulos seguintes, neste módulo focaremos apenas na lógica de programação.\nIMPORTANTE: O nome do arquivo não deve ter espaços (use sublinhado ou letras juntas, para compor nomes). Por exemplo:\nprimeiro_programa.cpp primeiroPrograma.cpp aplicacaoFuncional_01.cpp Os compiladores de C++ não impõem muitas restrições quanto ao nome do arquivo, mas existem convenções adotadas como boas práticas de programação. Além disso, os sistemas operacionais normalmente possuem regras de nomeação de arquivos que limitam o uso de alguns caracteres. Dessa forma, além do espaço, também evite a inclusão de caracteres especiais, acentos e cedilhas no nome do arquivo.\nEstrutura básica # A estrutura mínima e mandatória de um código em C++ é:\nint main() { } Todo o programa começa a executar dentro da função main(). É dentro dessas chaves que escrevemos as instruções que o computador deve seguir. Embora programas maiores incluam outras funções, bibliotecas e arquivos separados, a função main é sempre o ponto de partida obrigatório.\nO int antes de main indica que a função retorna ao sistema operacional um número inteiro, normalmente usado para sinalizar se o programa terminou com sucesso ou ocorreu algum erro.\nEsse código sozinho não faz nada visível. Vamos incrementa-lo para que exiba na tela uma mensagem de boas vindas:\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Bem vindo!\u0026#34;; return 0; } Ao ser executado, exibirá a mensagem:\nBem vindo! Vamos entender:\n#include \u0026lt; iostream \u0026gt; inclui ao seu arquivo a biblioteca padrão de C++ presente no compilador, permitindo o uso de recursos prontos de entrada e saída de dados, como leitura do teclado e exibição de informações na tela. std::cout é o recurso da biblioteca padrão iostream utilizado para exibir mensagens na tela. \u0026laquo; é o operador que envia o que vem à direita para o cout à esquerda. \u0026ldquo;Bem vindo!\u0026rdquo; é a nossa mensagem. Você pode alterar a mensagem, mas ela sempre deverá estar entre as aspas. ; Ponto e vírgula ao final da linha. As linhas de instrução são finalizadas com um ponto e vírgula, para sinalizar ao compilador o final da linha. return 0 retorna um código de saída com o valor zero para o sistema operacional, indicando que o programa terminou com sucesso. Exemplo com saída de dados # Vejamos um exemplo com múltiplas saídas:\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Iniciando a execução do programa.\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Bem vindo ao curso de C++. \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Programar é divertido!\u0026#34;; return 0; } A saída será:\nIniciando a execução do programa. Bem vindo ao curso de C++. Programar é divertido! Observe o std::endl adicionado ao final da linha com o operador \u0026laquo;.\nO operador \u0026laquo; funciona como um “encadeador de saída”: cada vez que ele é usado, adiciona mais um elemento ao que será mostrado.\nO símbolo endl indica quebra de linha, como o Enter do teclado. Precisamos adicionar a quebra de linha quando queremos que a próxima mensagem a ser impressa na tela apareça em uma nova linha. Sem o std::endl, a saída seria:\nIniciando a execução do programa.Bem vindo ao curso de C++.Programar é divertido! Exemplo com entrada de dados # Com o código a seguir, aprenderemos a introduzir dados ao programa utilizando o teclado:\n#include \u0026lt;iostream\u0026gt; int main() { std::string aluno; std::cout \u0026lt;\u0026lt; \u0026#34;Digite o seu nome:\u0026#34;; std::cin \u0026gt;\u0026gt; aluno; std::cout \u0026lt;\u0026lt; \u0026#34;Bem vindo, \u0026#34; \u0026lt;\u0026lt; aluno; return 0; } Ao executar, o programa imprimirá apenas a mensagem \u0026ldquo;Digite o seu nome:\u0026rdquo;, e ficará aguardando o usuário digitar alguma informação e finalizar com a tecla Enter do teclado. Se o usuário inserir, por exemplo, \u0026ldquo;Maria\u0026rdquo;, a saída será:\nDigite o seu nome: Bem vindo, Maria Vamos entender como esse código funciona:\nPrimeiro, precisamos reservar um espaço de memória do computador para armazenar o que será digitado no teclado. Chamamos esse espaço de variável. Fazemos isso com a instrução:\nstd::string aluno; string é o tipo da variável. O tipo define qual o tamanho do espaço que será armazenado na memória. aluno é a identificação da variável. Um nome que você pode escolher e que será utilizado sempre que precisar acessar o dado que ficou armazenado. Ou seja, com essa instrução, criamos uma variável chamada aluno do tipo string. Estudaremos com detalhes as variáveis e seus tipos na sequencia do curso.\nEm seguida, imprimimos uma mensagem na tela com std::cout como já aprendemos anteriormente. Esse código não recebe nenhuma informação de entrada.\nNa sequencia, temos o codigo responsável pela entrada de dados:\nstd::cin \u0026gt;\u0026gt; aluno; std::cin é o recurso da biblioteca padrão iostream utilizado para receber dados digitados pelo usuário no teclado. Por padrão, ele lê os caracteres até encontrar um espaço ou tabulação, ou uma quebra de linha (Enter). O operador \u0026raquo; pega os dados e envia para a variável aluno à direita. Para finalizar, imprimimos na tela uma mensagem persolizada com a instrução:\nstd::cout \u0026lt;\u0026lt; \u0026#34;Bem vindo, \u0026#34; \u0026lt;\u0026lt; aluno; Perceba que utilizamos novamente o operador \u0026laquo; para concatenar à mensagem \u0026ldquo;Bem vindo,\u0026rdquo; o valor armazenado na variável aluno.\nLembre-se que o operador \u0026laquo; é um “encadeador de saída”, e adicionará mais elementos à saída, seja um texto fixo entre aspas ou o valor de uma variável. Dessa forma, é possível montar mensagens personalizadas que combinam palavras e dados fornecidos pelo programa ou pelo usuário. Por exemplo, podemos adicionar uma exclamação ao final da mensagem com o comando:\nstd::cout \u0026lt;\u0026lt; \u0026#34;Bem vindo, \u0026#34; \u0026lt;\u0026lt; aluno \u0026lt;\u0026lt; \u0026#34;!!!\u0026#34;; Neste caso, a saída será:\nBem vindo, Maria!!! Namespace std # Repare que algumas das intruções que utilizamos até agora possuem a notação std:: como um prefixo. Vimos até agora em:\nstd::cout std::cin std::endl std::string O prefixo std:: é uma abreviação da palavra inglesa standard, e é utilizada para indicar que esses recursos pertencem a um \u0026ldquo;espaço de nomes\u0026rdquo; da biblioteca padrão do C++ (standard-library namespace). Sem o prefixo std::, o compilador não saberia onde procurar esses recursos.\n\u0026ldquo;Espaço de nomes\u0026rdquo; (ou namespace) é um recurso da linguagem muito útil para garantir organização e segurança no desenvolvimento de projetos grandes. Ele funciona como uma \u0026ldquo;etiqueta\u0026rdquo; que indica de onde o comando está vindo, evitando confusões caso existam nomes iguais em outras partes do programa.\nEstudaremos a criação e utilização de namespace em módulos seguintes. Nesse primeiro módulo, utilizaremos a diretiva using namespace std; no início do código para simplificar a escrita e evitar repetição. Com essa diretiva, não é mais necessário escrever o prefixo std:: em cada uso. Vejamos um exemplo:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Iniciando a execução do programa.\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Bem vindo ao curso de C++. \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Programar é divertido!\u0026#34;; return 0; } Comentários # As linguagens de programação normalmente permitem que o programador adicione comentários ao código. Comentários são trechos de texto inseridos no código com o objetivo de documentar e explicar a lógica implementada, sem serem executados pelo compilador. Comentários podem até servir para desativar temporariamente alguma parte do código durante o processo de desenvolvimento.\nExistem duas sintaxes de comentários em C++: de linha e de bloco.\nComentário de Linha # Utilizamos // para iniciar uma linha de comentário. Todo o conteúdo após as barras será ignorado pelo compilador. Ex:\n#include \u0026lt;iostream\u0026gt; using namespace std; // Este é um comentário de linha int main() { // Este é outro comentário de linha cout \u0026lt;\u0026lt; \u0026#34;Aprendendo sobre comentários!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } Comentário de Bloco # Utilizamos /* para iniciar um bloco de comentário e */ para finalizar, independente da linha ao qual se encontra. Todo o conteúdo entre /* e */ será ignorado pelo compilador. Ex:\n#include \u0026lt;iostream\u0026gt; using namespace std; /* Este é um comentário de bloco. Comentário de bloco pode conter múltiplas linhas. */ int main() { /* Este é outro comentário de bloco. Comentários são úteis para documentar o código! */ cout \u0026lt;\u0026lt; \u0026#34;Aprendendo sobre comentários!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } Variáveis e tipos básicos # Variáveis são espaços de memória reservados pelo programa para armazenar dados que podem ser utilizados e manipulados durante a execução. Uma variável precisa ser declarada com um nome, escolhido pelo programador, e um tipo. O tipo indica que tipo de informação pode ser armazenada, quais operações podem ser realizadas com a variável, e quanto de memória será usada para armazená-la.\nTipos de variáveis em C++ incluem:\nTipo Descrição Exemplos de declaração int Números inteiros int idade; int numero_1 = 5; int x = 5483; float Números fracionados float nota; float media = 19.7; float pi = 3.14159; bool Valor booleano, como verdadeiro ou falso. bool primeiro_acesso; bool aprovado = 1; boll estaAtivo = true; char Um único caracter char simbolo; char letra = 'A'; char resposta = 's'; string Sequencia de caracteres string nome; string curso = \u0026quot;Informática\u0026quot; string conteudo = \u0026quot;Material de estudos para a curso de informática.\u0026quot;; Notas:\nbool: Em C++, variáveis do tipo bool possuem o valor numérico 1 para representar verdadeiro e o valor 0 para representar falso. A linguagem permite o uso das palavras true e false no código para facilitar a leitura, mas internamente os valores numéricos equivalentes (1 e 0) é que serão armazenados na memória. char: O valor de uma variável do tipo char deve estar entre aspas simples. string: O valor de uma variável do tipo string deve estar entre aspas duplas. Segue um exemplo de código com declaração de variáveis e seus valores:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { // Variáveis do estudante string nome = \u0026#34;Maria\u0026#34;; // nome do estudante int idade = 20; // idade do estudante float notaMedia = 9.5; // nota média do estudante char turma = \u0026#39;B\u0026#39;; // turma do estudante bool aprovado = true; // status de aprovação // Exibindo as informações do estudante cout \u0026lt;\u0026lt; \u0026#34;Dados do estudante: \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34; Primeiro Nome: \u0026#34; \u0026lt;\u0026lt; nome \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34; Idade: \u0026#34; \u0026lt;\u0026lt; idade \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34; Nota Média: \u0026#34; \u0026lt;\u0026lt; notaMedia \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34; Turma: \u0026#34; \u0026lt;\u0026lt; turma \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34; Aprovado? \u0026#34; \u0026lt;\u0026lt; aprovado \u0026lt;\u0026lt; endl; // true será mostrado como 1 return 0; } A saída será:\nDados do estudante: Primeiro Nome: Maria Idade: 20 Nota Média: 8.5 Turma: B Aprovado? 1 Nós já aprendemos a ler informações do usuário utilizando o teclado como entrada de dados. Vejamos, então, um exemplo equivalente, no qual o usuário poderá fornecer as informações do aluno:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { // Declaração das variáveis sem valores iniciais string nome; int idade; float notaMedia; char turma; bool aprovado; // Solicitando os dados ao usuário cout \u0026lt;\u0026lt; \u0026#34;Digite o primeiro nome do estudante: \u0026#34;; cin \u0026gt;\u0026gt; nome; cout \u0026lt;\u0026lt; \u0026#34;Digite a idade: \u0026#34;; cin \u0026gt;\u0026gt; idade; cout \u0026lt;\u0026lt; \u0026#34;Digite a nota média: \u0026#34;; cin \u0026gt;\u0026gt; notaMedia; cout \u0026lt;\u0026lt; \u0026#34;Digite a turma (uma letra): \u0026#34;; cin \u0026gt;\u0026gt; turma; cout \u0026lt;\u0026lt; \u0026#34;O estudante foi aprovado? (1 = sim, 0 = não): \u0026#34;; cin \u0026gt;\u0026gt; aprovado; // Exibindo os dados coletados cout \u0026lt;\u0026lt; \u0026#34;Dados do estudante: \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Primeiro Nome: \u0026#34; \u0026lt;\u0026lt; nome \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Idade: \u0026#34; \u0026lt;\u0026lt; idade \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Nota Média: \u0026#34; \u0026lt;\u0026lt; notaMedia \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Turma: \u0026#34; \u0026lt;\u0026lt; turma \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Aprovado? \u0026#34; \u0026lt;\u0026lt; aprovado \u0026lt;\u0026lt; endl; return 0; } Operadores # Operadores são símbolos especiais usados para realizar operações sobre variáveis e valores. Eles permitem executar cálculos, comparar dados e tomar decisões dentro do programa. Os principais grupos de operadores que veremos a seguir são:\nOperadores aritméticos Operadores relacionais Operadores lógicos Operadores aritméticos # Esses operadores são usados para realizar cálculos matemáticos. Eles funcionam com variáveis numéricas, como int e float.\nOperador Operação Exemplo de uso + Adição resultado = a + b - Subtração resultado = a - b * Multiplicação resultado = a * b / Divisão resultado = a / b % Resto da divisão (módulo) resto = a % b ++ Incremento (aumenta o valor da variável em 1) a++ ou ++a -- Decremento (reduz o valor da variável em 1) b-- ou --b Os operadores de incremento (++) e decremento (- -) podem ser usados antes ou depois da variável. O modo é chamado de pré-fixado ou pós-fixado:\nNo pré-fixado (++a, --b), a variável é atualizada antes de ser usada na expressão. No pós-fixado (a++, b--), a variável é usada primeiro, e só depois é atualizada, ou seja, na próxima linha de instrução. Operadores relacionais # São usados para comparar valores. O resultado dessas comparações é sempre verdadeiro (true) ou falso (false).\nOperador Operação Exemplo de uso == Igual a resultado = (a == b) != Diferente de resultado = (a != b) \u0026gt; Maior que resultado = (a \u0026gt; b) \u0026lt; Menor que resultado = (a \u0026lt; b) \u0026gt;= Maior ou igual a resultado = (a \u0026gt;= b) \u0026lt;= Menor ou igual a resultado = (a \u0026lt;= b) Operadores lógicos # São utilizados para combinar expressões lógicas (condições). O resultado também é sempre true ou false.\nOperador Operação Exemplo de uso \u0026amp;\u0026amp; E lógico (verdadeiro se ambas as condições forem verdadeiras) resultado = (a \u0026gt; b \u0026amp;\u0026amp; b \u0026lt; c) || OU lógico (verdadeiro se pelo menos uma condição for verdadeira) resultado = (a \u0026gt; b || b \u0026lt; c) ! NÃO lógico (inverte o valor lógico da expressão) resultado = !(a \u0026gt; b) Exemplo de uso # Segue exemplo mais completo de utilização dos operadores:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10, b = 3, c = 5; // Operadores aritméticos cout \u0026lt;\u0026lt; \u0026#34;Soma: \u0026#34; \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Subtração: \u0026#34; \u0026lt;\u0026lt; a - b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Multiplicação: \u0026#34; \u0026lt;\u0026lt; a * b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Divisão: \u0026#34; \u0026lt;\u0026lt; a / b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Resto: \u0026#34; \u0026lt;\u0026lt; a % b \u0026lt;\u0026lt; endl; // Operadores relacionais cout \u0026lt;\u0026lt; \u0026#34;a é igual a b? \u0026#34; \u0026lt;\u0026lt; (a == b) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a é maior que b? \u0026#34; \u0026lt;\u0026lt; (a \u0026gt; b) \u0026lt;\u0026lt; endl; // Operadores lógicos cout \u0026lt;\u0026lt; \u0026#34;a \u0026gt; 5 e b \u0026lt; 5? \u0026#34; \u0026lt;\u0026lt; (a \u0026gt; 5 \u0026amp;\u0026amp; b \u0026lt; 5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a \u0026gt; 5 ou b \u0026gt; 5? \u0026#34; \u0026lt;\u0026lt; (a \u0026gt; 5 || b \u0026gt; 5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a não é menor que b? \u0026#34; \u0026lt;\u0026lt; !(a \u0026lt; b) \u0026lt;\u0026lt; endl; //Operadores unários de incremento e decremento cout \u0026lt;\u0026lt; \u0026#34;Incremento pré-fixado: \u0026#34; \u0026lt;\u0026lt; ++c \u0026lt;\u0026lt; endl; // imprime 6 c = 5; cout \u0026lt;\u0026lt; \u0026#34;Incremento pós-fixado: \u0026#34; \u0026lt;\u0026lt; c++ \u0026lt;\u0026lt; endl; // imprime 5, mas depois \u0026#39;c\u0026#39; passa a valer 6 return 0; } A saída esperada é:\nSoma: 13 Subtração: 7 Multiplicação: 30 Divisão: 3 Resto: 1 a é igual a b? 0 a é maior que b? 1 a \u0026gt; 5 e b \u0026lt; 5? 1 a \u0026gt; 5 ou b \u0026gt; 5? 1 a não é menor que b? 1 Incremento pré-fixado: 6 Incremento pré-fixado: 5 Na saída dos exemplos com operadores lógicos e/ou relacionais, lembre-se que 1 significa verdadeiro e 0 significa falso.\nEstrutura condicional: if else # Utilizamos estruturas condicionais para permitir que o programa tome decisões sobre qual parte do código será executado com base em alguma condição. A forma geral da estruutra é:\nif (condição) { // bloco de código executado se a condição for verdadeira } else { // bloco de código executado se a condição for falsa } A estrutura if (do inglês, \u0026ldquo;se\u0026rdquo;) é usada para executar um bloco de código apenas se uma condição for verdadeira. A estrutura else (do inglês, \u0026ldquo;senão\u0026rdquo;) é opcional, e permite definir um bloco alternativo de instruções, que será executado caso a condição seja falsa.\nA condição é uma expressão que deve resutlar em um valor booleano (verdadeiro ou falso). Para isso, utilizamos operadores relacionais (como ==, \u0026gt;, \u0026lt;, !=) e lógicos (como \u0026amp;\u0026amp;, ||, !), conforme já estudado.\nExemplo:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { float nota; cout \u0026lt;\u0026lt; \u0026#34;Digite a nota do aluno: \u0026#34;; cin \u0026gt;\u0026gt; nota; if (nota \u0026gt;= 7.0) { cout \u0026lt;\u0026lt; \u0026#34;Aluno aprovado!\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;Aluno reprovado!\u0026#34;; } return 0; } Estruturas condicionais também podem ser aninhadas, permitindo testar condições em sequência. Por exemplo:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { float temperatura; cout \u0026lt;\u0026lt; \u0026#34;Digite a temperatura em graus Celsius: \u0026#34;; cin \u0026gt;\u0026gt; temperatura; if (temperatura \u0026gt;= 35.0) { cout \u0026lt;\u0026lt; \u0026#34;Clima quente!\u0026#34;; } else if (temperatura \u0026gt;= 25.0) { cout \u0026lt;\u0026lt; \u0026#34;Clima agradável.\u0026#34;; } else if (temperatura \u0026gt;= 15.0) { cout \u0026lt;\u0026lt; \u0026#34;Clima ameno.\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;Clima frio.\u0026#34;; } return 0; } Vejamos mais um exemplo, no qual a comparação da estrutura condicional é feita com variável do tipo string:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string turno; cout \u0026lt;\u0026lt; \u0026#34;Digite o turno em que você estuda (manha, tarde ou noite): \u0026#34;; cin \u0026gt;\u0026gt; turno; if (turno == \u0026#34;manha\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;Bom dia!\u0026#34;; } else if (turno == \u0026#34;tarde\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;Boa tarde!\u0026#34;; } else if (turno == \u0026#34;noite\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;Boa noite!\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;Turno inválido. Verifique o valor digitado.\u0026#34;; } return 0; } Estrutura de repetição: for # A estrutura de repetição (ou laço) for permite que um bloco de código seja executado várias vezes, enquanto uma condição específica for verdadeira. A sintaxe geral é:\nfor (inicialização; condição; incremento) { // bloco de código que será repetido } No qual:\ninicialização: define e inicializa uma variável de controle do laço de repetição. Ex. ``ìnt i = 0```. condição: é uma expressão lógica que é verificada antes de cada repetição. Enquanto for verdadeira, o bloco será executado. Ex. i \u0026lt; 5. incremento/decremento: atualiza a variável de controle a cada repetição. Ex. i++. Com essas três etapas, o comando for repete o bloco de código delimitado por { } enquanto a condição permanecer verdadeira. Normalente, a mudança de estado dessa condição - de verdadeiro pra falso - ocorre graças à atualização da variável de controle, feita por meio de um incremento ou decremento a cada repetição.\nExemplo:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { for (int i = 1; i \u0026lt;= 5; i++) { cout \u0026lt;\u0026lt; \u0026#34;Número: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } A saída será:\nNúmero: 1 Número: 2 Número: 3 Número: 4 Número: 5 Vejamos um exemplo semelhante, mas com decremento da variável de controle:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { for (int i = 5; i \u0026gt;= 1; i--) { cout \u0026lt;\u0026lt; \u0026#34;Número: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } A saída será:\nNúmero: 5 Número: 4 Número: 3 Número: 2 Número: 1 Segue mais um exemplo, agora, com leitura de dados dentro da estrutura de repetição. No exemplo, o algoritmo lê o valor de uma nota a cada repetição, e calcula incrementalmente a média das notas:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { float nota, soma = 0; int quantidade = 5; for (int i = 1; i \u0026lt;= quantidade; i++) { cout \u0026lt;\u0026lt; \u0026#34;Digite a nota \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; cin \u0026gt;\u0026gt; nota; soma += nota; // soma = soma + nota } float media = soma / quantidade; cout \u0026lt;\u0026lt; \u0026#34;A média das notas é: \u0026#34; \u0026lt;\u0026lt; media \u0026lt;\u0026lt; endl; return 0; } Um exemplo de saída é:\nDigite a nota 1: 8 Digite a nota 2: 7 Digite a nota 3: 9 Digite a nota 4: 6 Digite a nota 5: 8 A média das notas é: 7.6 Estrutura de repetição: while # A estutura while, semelhante à estrutura for, também é utilizada para repetir um bloco de código enquanto uma condição for verdadeira. A sintaxe geral é:\nwhile (condição){ //bloco de código que será repetido } Perceba que a estrutura do while não inclui, em sua própria sintaxe, a inicialização nem o incremento da variável de controle, como vimos no for. Por isso, esses comandos precisam ser escritos separadamente no código: a inicialização antes do início do laço, e o incremento dentro do bloco de repetição.\nVejamos um exemplo:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i = 1; // Inicializa a variável de controle while (i \u0026lt;= 5) { cout \u0026lt;\u0026lt; \u0026#34;Número: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; i++; // Incrementa a variável de controle } return 0; } A saída será:\nNúmero: 1 Número: 2 Número: 3 Número: 4 Número: 5 Segue uma versão do algoritmo para cálculo de média de notas informadas pelo usuário (visto na seção da estrutura for), utilizando a estrutura while:\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { float nota, soma = 0; int quantidade = 5; int i = 0; while (i \u0026lt;= quantidade) { cout \u0026lt;\u0026lt; \u0026#34;Digite a nota \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; cin \u0026gt;\u0026gt; nota; soma += nota; // soma = soma + nota i++; } float media = soma / quantidade; cout \u0026lt;\u0026lt; \u0026#34;A média das notas é: \u0026#34; \u0026lt;\u0026lt; media \u0026lt;\u0026lt; endl; return 0; } Funções # Em programação, uma função é um bloco de código reutilizável que executa uma tarefa específica. O uso de funções deixa o código mais organizado, pois separa as partes do programa em blocos menores e mais compreensíveis.\nUma função pode, opcionalmente, receber valores de entrada, e também pode retornar um resultado como saída da função. Chamados de parâmetros de entrada e parâmetro de saída.\nVejamos, primeiro, a estrutura básica de uma função sem parâmetros de entrada e de saída:\nvoid nome_da_função() { //Bloco de código da função } Segue um exemplo de declaração e chamada de uma função:\n#include \u0026lt;iostream\u0026gt; using namespace std; void mensagemBoasVindas() { cout \u0026lt;\u0026lt; \u0026#34;Bem-vindo ao curso de C++!\u0026#34; \u0026lt;\u0026lt; endl; } int main() { mensagemBoasVindas(); // chamada da função return 0; } A saída será:\nBem-vindo ao curso de C++! Vamos entender:\nAssim como nome de variáveis, nomes de funções são escolhidos pelo programador, e seguem as mesmas regras de nomeação de variáveis (podem conter letras, números e o caracterer sublinhado (_), devendo começar com uma letra ou sublinhado). O nome da função é mensagemBoasVindas. Ela foi declarada antes do bloco da função main(). void indica que a função não terá retorno. Para que a função seja executada, ela precisa ser chamada em algum ponto do código. Nesse exemplo, chamamos a função dentro do bloco main() com a instrução mensagemBoasVindas();. O código começa a ser executado a partir do bloco main(). Nesse exemplo, a primeiro instrução do bloco é a chamada da função. Dessa forma, o fluxo de execução é redirecionado para o bloco de instruções da função. Ao finalizar o bloco da função, o fluxo de execução retorna para a próxima instrução do bloco main(). Vejamos outro exemplo, com declaração de duas funções:\n#include \u0026lt;iostream\u0026gt; using namespace std; // Primeira função void primeiraFuncao() { cout \u0026lt;\u0026lt; \u0026#34;Mensagem da primeira função.\u0026#34; \u0026lt;\u0026lt; endl; } // Segunda função void segundaFuncao() { cout \u0026lt;\u0026lt; \u0026#34;Mensagem da segunda função.\u0026#34; \u0026lt;\u0026lt; endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;Início do programa no main.\u0026#34; \u0026lt;\u0026lt; endl; primeiraFuncao(); // chama a primeira função cout \u0026lt;\u0026lt; \u0026#34;De volta ao main, depois da primeira função.\u0026#34; \u0026lt;\u0026lt; endl; segundaFuncao(); // chama a segunda função cout \u0026lt;\u0026lt; \u0026#34;Final do programa no main.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } A saída será:\nInício do programa no main. Mensagem da primeira função. De volta ao main, depois da primeira função. Mensagem da segunda função. Final do programa no main. Com retorno # A estrutura básica para declarar uma função com tipo de retorno é:\ntipo_de_retorno nome_da_função() { //Bloco de código da função return valor; } O tipo_de_retorno indica o tipo de dado que a função entregará de volta após ser executada. Esse tipo pode ser, por exemplo, int, float, str, string, entre outros. Quando a função não precisa devolver nenhum valor, como vimos na seção anterior, utiliza-se o tipo void. Para retornar um valor ao ponto do programa onde a função foi chamada, utilizamos a instrução return, seguida do valor compatível com o tipo de retorno definido. Exemplo:\n#include \u0026lt;iostream\u0026gt; using namespace std; // Função que retorna um número inteiro int somar() { int a = 5; int b = 3; return a + b; // Retorna o resultado da soma } int main() { int resultado = somar(); // Recebe o valor retornado pela função cout \u0026lt;\u0026lt; \u0026#34;O resultado da soma é: \u0026#34; \u0026lt;\u0026lt; resultado \u0026lt;\u0026lt; endl; return 0; } No exemplo acima, a função somar() realiza uma operação e retorna o valor da soma para o ponto onde foi chamada. O valor é então armazenado na variável resultado dentro do main().\nPoderíamos, também, retornar um valor diretamente, ou uma variável, como no exemplo a seguir:\n#include \u0026lt;iostream\u0026gt; using namespace std; // Função que retorna um número inteiro int somar() { int a = 5; int b = 3; int soma = a + b return soma; // Retorna a variável com o resultado da soma } int main() { int resultado = somar(); // Recebe o valor retornado pela função cout \u0026lt;\u0026lt; \u0026#34;O resultado da soma é: \u0026#34; \u0026lt;\u0026lt; resultado \u0026lt;\u0026lt; endl; return 0; } Com parâmetros de entrada # Uma função com parâmetros de entrada não depende apenas de valores fixos dentro dela. Ela trabalha com valores fornecidos pelo programa no momento da chamada, através dos parâmetros de entrada.\nA estrutura básica é:\n// Com um parâmetro de entrada tipo_de_retorno nome_da_função(tipo_do_parametro parametro) { //Bloco de código da função return valor; } // Com mais de um parâmetro de entrada: tipo_de_retorno nome_da_função(tipo1 parametro1, tipo2 parametro2, ...) { //Bloco de código da função return valor; } Lembrando que o retorno da função é opcional e não depende dos parâmetros de entrada. Se não tiver um retorno, utilizamos o void na declaração da função.\nSegue um exemplo da função somar(), visto na seção anterior, mas agora com parâmetros de entrada:\n#include \u0026lt;iostream\u0026gt; using namespace std; // Função que retorna um número inteiro int somar(int a, int b) { return a + b; // Retorna o resultado da soma } int main() { int valor_1 = 5; int valor_2 = 3; int resultado = somar(valor_1, valor_2); // Recebe o valor retornado pela função cout \u0026lt;\u0026lt; \u0026#34;O resultado da soma é: \u0026#34; \u0026lt;\u0026lt; resultado \u0026lt;\u0026lt; endl; return 0; } Nesse exemplo, a função somar() recebe dois parâmetros de entrada (a e b), cujos valores são passados na chamada da função através de variáveis que foram declaradas no bloco main(). As variáveis valor_1e valor_2 não fazem parte da função somar() e não podem ser alteradas pela função, apenas os seus valores serão copiados.\nVejamos mais alguns exemplos de chamada de função:\n#include \u0026lt;iostream\u0026gt; using namespace std; // Função que retorna um número inteiro int somar(int a, int b) { return a + b; // Retorna o resultado da soma } int main() { int valor_1 = 0; int valor_2 = 0; int resultado = 0; cout \u0026lt;\u0026lt; \u0026#34;Digite o valor 1: \u0026#34;; cin \u0026gt;\u0026gt; valor_1; cout \u0026lt;\u0026lt; \u0026#34;Digite o valor 2: \u0026#34;; cin \u0026gt;\u0026gt; valor_2; resultado = somar(valor_1, valor_2); cout \u0026lt;\u0026lt; \u0026#34;O resultado da soma é: \u0026#34; \u0026lt;\u0026lt; resultado \u0026lt;\u0026lt; endl; //Chamada diretamente com valores resultado = somar(3, 9); cout \u0026lt;\u0026lt; \u0026#34;O novo resultado da soma é: \u0026#34; \u0026lt;\u0026lt; resultado \u0026lt;\u0026lt; endl; return 0; } Segue mais um exemplo de função:\n#include \u0026lt;iostream\u0026gt; using namespace std; // Função que recebe duas notas e calcula a média float calcularMedia(float n1, float n2) { float media = (n1 + n2) / 2; if (media \u0026gt;= 7.0) cout \u0026lt;\u0026lt; \u0026#34;Aluno aprovado!\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;Aluno reprovado!\u0026#34; \u0026lt;\u0026lt; endl; return media; } int main() { float nota1, nota2; cout \u0026lt;\u0026lt; \u0026#34;Digite as duas notas do aluno: \u0026#34;; cin \u0026gt;\u0026gt; nota1 \u0026gt;\u0026gt; nota2; float m = calcularMedia(nota1, nota2); cout \u0026lt;\u0026lt; \u0026#34;A média final foi: \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } Com múltiplos retornos # Uma função pode ter mais de um comando return dentro de seu bloco de código. O return não apenas envia um valor de volta ao programa chamador, mas também encerra imediatamente a execução da função, e nada depois dele é executado. Isso significa que a execução da função pode terminar em diferentes momentos, dependendo das condições verificadas.\nExemplo:\n#include \u0026lt;iostream\u0026gt; using namespace std; // Função que avalia a média e retorna uma mensagem string verificarSituacao(float media) { if (media \u0026gt;= 7.0) { return \u0026#34;Aprovado!\u0026#34;; } else if (media \u0026gt;= 3.0) { return \u0026#34;Em recuperação.\u0026#34;; } else { return \u0026#34;Reprovado.\u0026#34;; } } int main() { float nota; cout \u0026lt;\u0026lt; \u0026#34;Digite a média do aluno: \u0026#34;; cin \u0026gt;\u0026gt; nota; string resultado = verificarSituacao(nota); cout \u0026lt;\u0026lt; \u0026#34;Situação do aluno: \u0026#34; \u0026lt;\u0026lt; resultado \u0026lt;\u0026lt; endl; return 0; } \u0026hellip;\n(EM DESENVOLVIMENTO)\n\u0026hellip;\n"},{"id":2,"href":"/docs/03-c-course/intermediate/","title":"2023 - Atividades","section":"Introdução à Programação com a Linguagem C","content":" Atividades # "},{"id":3,"href":"/docs/04-c++/intermediate/","title":"2023 - Atividades","section":"CURSO: Informática com C++","content":"Um compilador é um programa de computador que traduz o código que você escreve em uma linguagem de programação (como C ou C++) para uma linguagem que o computador realmente entende: código de máquina.\nC é uma linguagem de propósito geral. Isso quer dizer que ela pode ser utilizada para escrever programas para várias àreas diferentes. Sua linguagem segue um padrão procedural, permitindo a decomposição de problemas grande e complexos em procedimentos (módulos) separados e mais simples.\nComo toda linguagem de programação, C possui um conjuto de palavras reservadas que são utilizadas para a criação das instruções que comporão um programa. Essa é uma lista de palavras reservadas em C:\n(Fonte: C11 – Draft version (N1570) - http://port70.net/~nsz/c/c11/n1570.html)\nPrimeiro programa em C # Agora vamos executar o primeiro código em C. Ao ser executado, o programa irá imprimir na tela a mensagem \u0026ldquo;Olá, mundo lindo!\u0026rdquo;. Digite o seguinte texto (código-fonte) em um arquivo chamado primeiro_programa.c:\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Olá, mundo lindo!\u0026#34;); return 0; } Vamos entender:\nVocê criará muitos arquivos com códigos em C daqui pra frente, e existem regras para a nomeação desses arquivos. As regras são:\nO arquivo deve ter a extensão .c. Não podem haver espaços no nome do arquivo. Por exemplo: \u0026ldquo;primeiro programa.c\u0026rdquo;. A maioria dos arquivos começará com instruções #include \u0026lt; \u0026hellip; \u0026gt;, chamadas de cabeçalho do programa. #include é uma instrução utilizada para adicionarmos procedimentos (funções) que já foram programados previamente. No exemplo, estamos adicionando ao nosso programa um arquivo presente no compilador C que foi instalado na sua máquina. O arquivo stdio.h contém código C (entederemos mais à frente a extensão .h) com procedimentos que permitem a entrada e saída de textos na tela. stdio é uma abreviação de \u0026ldquo;standard input/output\u0026rdquo;.\nint main (){ \u0026hellip; } é uma sintaxe mandatória que identifica o ponto inicial de execução do seu código. Quando executado, o seu programa começará a executar as instruções criadas dentro desse bloco delimitado pelas chaves { }. Entenderemos melhor essa estrutura quando estudarmos a declaração de funções em C. No exemplo, temos duas instruções dentro do bloco main:\nprintf é uma função definida no arquivo stdio.h para impressão de textos na tela. O texto que será impresso deve ser colocado entre aspas. return é uma palavra reservada utilizada para finalizar a execução de um bloco de código. Mais um exemplo de código:\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Programação requer prática. \\n Pratique!\u0026#34;); printf(\u0026#34;\\n Pratique!\u0026#34;); return 0; } Neste exemplo acrescentamos ao texto dentro do printf uma sequência de escape. Perceba que tem um \\n no meio do texto do primeiro printf, e no inicio do texto do segundo printf. Sequências de escape são utilizados em textos para a inserção de caracteres especiais. O \\n representa quebra de linha, como um enter do teclado. Dessa forma, a saída do programa será:\nProgramação requer prática. Pratique! Pratique! Básico da Linguagem C # Estudaremos primeiro o que considero funcionalidades básicas da linguagem.\nComentários # Além de instruções, o seu programa pode conter comentários para auxiliar o entendimento do código. É uma boa prática de programação documentar o seu código com comentários informativos e instrutivos para auxiliar a manutenção do código. Existem dois tipos de comentários em C: de linha e de bloco. Ambos são ignorados pelo compilador na criação do arquivo executável do programa.\nO comentário de linha se inicia com duas barras (//) e seu escopo finaliza ao final de uma linha:\n//Este é um comentário de linha. //Este é outro comentário de linha. O comentário de bloco é delimitado pelos símbolos /* para abertura e */ para fechamento do bloco. Todas as linhas dentro do bloco fazem parte do mesmo comentário.\n/* Este é um comentário de bloco */ /* Este também é um comentário de bloco */ Ponto e vírgula # C utiliza ponto e vírgula como delimitador de instruções. É a forma que o compilador utiliza para saber como ler e separar as instruções no código. Note que, no nosso exemplo, temos duas instruções que são finalizadas com ponto e vírgula:\nprintf(\u0026#34;Olá, mundo lindo!\u0026#34;); return 0; Algumas instruções já possuem o próprio delimitador, e não precisam de ponto e vírgula. Será fácil identificá-las quando você avançar no curso.\nVariáveis # Os dados que criamos e manipulamos em nosso programa precisam ser armazenados na memória do computador para que possam ser referenciados e utilizados no código. Linguagens de programação utilizam variáveis para este propósito. Em C, uma variável deve ser declarada no código com o seu tipo e um nome.\n//Sintaxe de instrução para criação de variável tipo nome; Os tipos são convenções definidas na linguagem, para que o compilador saiba a quantidade de memória máxima que será reservada para armazenar dados na variável. Os tipos básicos em C são:\nTipo Tamanho Descrição char 8 bits Armazena códigos correspondentes a um caractere da tabela ASCII. int 16 bits ou 32 bits Armazena números inteiros (positivos e negativos). float 32 bits Armazena números fracionários, com precisão de até sete dígitos. double 64 bits Armazena números fracionários, com precisão de até 15 dígitos. Estudaremos mais sobre os tipos de variáveis e como podem ser modificados ao longo do curso.\nExemplo de declaração de variáveis de cada tipo:\nint x; float y; char z; double k; Variáveis do mesmo tipo podem ser declaradas na mesma linha, separadas por vírgula. Exemplo:\nint x, w, q; //declaração de três variáveis do tipo int O nome da variável pode ser utilizado em diferentes partes do código para acessarmos o conteúdo presente na posição de memória correspondente.\nExistem regras para a nomeação das variáveis. São estas:\nPodem utilizar letras maiúsculas, letras minúsculas, números e o caractere sublinhado; Não podem ser iniciados com números; Não podem ser idênticos às palavras reservadas da linguagem. Exemplos de nomes válidos e inválidos:\n//Exemplos de nomes válidos int nomeValido01; float nome_valido_02; char _nomeValido_03; //Exemplos de nomes inválidos int int; int 2nome_invalido; Operador de atribuição # Como na matemática, atribuimos valor às variáveis com o símbolo de atribuição =. Podemos atribuir valor à uma variável em sua declaração, ou em outras partes do código após a sua declaração. Exemplos:\n//Atribuição de valores em conjunto com a declaração da variável int x = 10; //leia-se: x recebe o valor 10 float y = 10.123; char z = \u0026#39;a\u0026#39;; //Atribuição de valores após a criação das variáveis x = 12; z = 15.0; z = \u0026#39;b\u0026#39;; Podemos atribuir valor à mesma variável quantas vezes quisermos no mesmo programa, o valor da variável sempre é apagado da memória e substituído pelo valor mais recente que for atribuído.\nUma variável também pode receber o valor de outra variável na atribuição, por exemplo:\nint x, y; x = 10; y = x; // Atribuímos o valor 10 da variável x à variável y. Equivale à y = 10; Podemos também concatenar as atribuições de valores, por exemplo:\n//Atribuição na declaração concatenada de variáveis do mesmo tipo int x = 1, y = 2, z = 3; //Atribuição do mesmo valor à mais de uma variável. x = y = z = 4; Ao tipo char podem ser atribuídos o caractere envolto em aspas simples, como nos exemplos acima, ou o número inteiro correspondente da tabela ASCII. Exemplo:\nz = \u0026#39;c\u0026#39;; z = 99; //Na tabela ASCII, 99 é o valor decimal do caractere c. Lendo e imprimindo valores de variáveis # Nós já aprendemos a imprimir textos na tela com o comando printf(). Também utilizamos o printf() para imprimir valores de variáveis. Para isso, o comando requer a sinalização do tipo de variável que será impressa. A linguagem C utiliza uma sequência de caracteres para fazer essa sinalização, e cada tipo de variável tem um sinalizador diferente. Exemplos de sequências são:\nCaracteres Tipo de variável %d int %f float %c char Exemplos de comandos com impressão de variáveis:\nint var_int = 10; float var_float = 10.5; char var_char = \u0026#39;A\u0026#39;; printf(\u0026#34;%d\u0026#34;, var_int); printf(\u0026#34;%f\u0026#34;, var_float); printf(\u0026#34;%c\u0026#34;, var_char); Podemos concatenar valores de variáveis com textos que serão impressos na tela. Por exemplo:\nint var_int = 10; float var_float = 10.5; char var_char = \u0026#39;A\u0026#39;; printf(\u0026#34;O valor da variável tipo int é: %d.\u0026#34;, var_int); printf(\u0026#34;O valor %f pertence à variável do tipo float.\u0026#34;, var_float); printf(\u0026#34;%c é o conteúdo da variável var_char.\u0026#34;, var_char); printf(\u0026#34;Os valores das variáveis são: %d, %f, %c\u0026#34;, var_int, var_float, var_char); Para permitir que o usuário insira valores no programa, podemos ler informações digitadas no teclado com o comando scanf(). Seguem exemplos de utilização:\nint var_int; float var_float; char var_char; printf(\u0026#34;Digite um valor inteiro:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;var_int); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026#34;Digite um valor fracionado:\u0026#34;); scanf(\u0026#34;%f\u0026#34;, \u0026amp;var_float); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026#34;Digite um caractere:\u0026#34;); scanf(\u0026#34;%c\u0026#34;, \u0026amp;var_char); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026#34;Os valores digitados são: %d, %f, %c\u0026#34;, var_int, var_float, var_char); Assim como o printf, o scanf é uma função definida na biblioteca padrão da linguagem C, presente no arquivo stdio.h.\nOperadores aritméticos binários # Variáveis numéricas podem compor expressões aritméticas no código. Os operadores aplicados em C são:\nOperador Descrição Exemplo + soma z = x + y; - subtração z = x - y; * multiplicação z = x + y; / divisão z = x / y; % resto da divisão z = x % y; Da mesma forma que na matemática, a multiplicação e a divisão têm precedência à soma e à subtração. Para entender a execução de expressões com operadores de mesma precedência, saiba que a linguagem executará as operações da esquerda para a direita. Os parênteses também podem ser utilizados para organização de precedência na execução.\nOs operadores exemplificados acima são binários. Isto quer dizer que requerem dois elementos para realizar a operação. Nos exemplos da tabela temos x e y. Outros exemplos válidos são:\ny = 1 + 2; x = x + x; x = x - 1; z = 10 * y; Operadores aritméticos unários # Os operadores de adição e subtração também podem ser utilizados com uma única variável para incremento ou decremento do valor da variável. Neste caso, dizemos que o operador é unário. A sintaxe é diferente, pois duplicamos o operador. Veja os exemplos:\nx++; // equivale a x = x + 1; y--; // equivale a y = y - 1; Nos exemplos acima, o novo valor da variável será acessível a partir da próxima linha de código. Existe ainda a possibilidade de anteciparmos o acesso ao novo valor para a mesma linha da instrução que altera a variável. Para isso, mudamos a ordem dos operadores para:\n++x; // também incrementa 1 ao valor de x; --y; // também decrementa 1 ao valor de y; O operador de subtração também pode ser utilizado de forma unária para a declaração de números negativos. Exemplo:\nx = -1; y = - 10; Operadores relacionais # Operadores relacionais são utilizados para formar expressões que comparam dois ou mais elementos, para obter o resultado verdadeiro ou falso. Os operadores relacionais em C são:\nOperador Descrição Exemplo \u0026gt; maior que x \u0026gt; y \u0026lt; menor que x \u0026lt; y \u0026gt;= maior ou igual x \u0026gt;= y \u0026lt;= menor ou igual x \u0026lt;= y == igual a x == y != diferente de x != y Em C, as expressões relacionais retornam o valor 0 para informar que a expressão é falsa, e o valor 1 se o resultado da expressão for verdadeiro. Por exemplo:\nint x = 1, y = 2, z; z = x \u0026lt; y; // z recebe o valor 1, pois a expressão (1 é menor que 2) é verdadeira z = x == y; // z recebe o valor 0, pois a expressão (1 é igual a 2) é falsa Operadores lógicos # A lógica boleana é frequentemente utilizada quando programamos. Com a lógica boleana, podemos compor expressões utilizando os operadores binários E e OU, e o operador unário de negação NÃO. Os resultados das expressões serão sempre verdadeiros ou falsos. A semântica dos operadores está resumida nas tabelas abaixo:\nTabela do operador E (Lemos assim: verdadeiro e verdadeiro, é igual a verdadeiro):\nOperando Operador Operando Resultado verdadeiro E verdadeiro verdadeiro verdadeiro E falso falso falso E verdadeiro falso falso E falso falso Tabela do operador OU:\nOperando Operador Operando Resultado verdadeiro OU verdadeiro verdadeiro verdadeiro OU falso verdadeiro falso OU verdadeiro verdadeiro falso OU falso falso A tabela do operador de negação é mais simples. Vamos inverter a ordem do operador, para ler assim: \u0026ldquo;Não verdadeiro, é igual a falso.\u0026rdquo;:\nOperador Operando Resultado NÃO verdadeiro falso NÃO falso verdadeiro Em C, a sintaxe dos operadores boleanos E e OU é, respectivamente, \u0026amp;\u0026amp; e ||. A sintaxe do operador NÃO é o símbolo de exclamação !. Lembremos que, como resultado de expressões, o 0 representa falso e 1 representa verdadeiro. Dessa forma, utilizando a sintaxe em C, as tabelas são:\nOperador \u0026amp;\u0026amp; (E):\nOperando Operador Operando Resultado 1 \u0026amp;\u0026amp; 1 1 1 \u0026amp;\u0026amp; 0 0 0 \u0026amp;\u0026amp; 0 0 0 \u0026amp;\u0026amp; 0 0 Operador || (OU):\nOperando Operador Operando Resultado 1 || 1 1 1 || 0 1 0 || 0 1 0 || 0 0 Operador de negação ! :\nOperador Operando Resultado ! 1 0 ! 0 1 Os operadores lógicos são comumente utilizados em conjunto com outros operadores, por exemplo:\nint x = 1, y = 2, z = 3, w; w = (x \u0026lt; y) \u0026amp;\u0026amp; (x \u0026lt; z); // w recebe o valor 1, como resultado de (1) \u0026amp;\u0026amp; (1) w = (x == y) \u0026amp;\u0026amp; (x \u0026lt; z); // w recebe o valor 0, como resultado de (0) \u0026amp;\u0026amp; (1) w = (x \u0026gt;= y) || (x \u0026lt; z); // w recebe o valor 1, como resultado de (0) || (1) w = (x == y) || (x == z); // w recebe o valor 0, como resultado de (0) || (0) w = !(x == y); // w recebe o valor 1, como resultado de !(0) Comandos condicionais # Podemos adicionar avaliação de condições no código para decidir se um conjunto de instruções deverá ser executado. Condições são expressões cujo resultado será verdadeiro ou falso. Uma vez verdadeiro, o código associado à estrutura condicional será executado. A linguagem C possui três formas de estruturas condicionais:\nif-else switch-case E a estrutura condição ? verdadeiro : falso. IF-ELSE # Vamos começar entendo a estrutura de código condicional utilizando apenas o comando IF. A sintaxe do comando é: (Leia-se: SE condição for verdadeira, ENTÃO a instrução seguinte será executada. )\nif (condição) instrução; Por exemplo, considere uma variável x, cujo valor será inserido pelo usuário: (Leia-se: SE x for maior que zero, ENTÃO imprima na tela o texto \u0026ldquo;O valor de x é positivo\u0026rdquo;. )\nif (x \u0026gt; 0) printf(\u0026#34;O valor de x é positivo.\u0026#34;); A sintaxe acima funciona apenas para avaliação condicional de uma única linha de instrução. Para incluir mais linhas de instrução, devemos adicionar um par de chaves {} para iniciar e fechar um bloco de instruções. Dessa forma, todas as instruções dentro do bloco serão executadas apenas se a condição for verdadeira.\nif (condição){ // inicio do bloco de instruções; instrução_01; instrução_02; ... instrução_N; } // final do bloco de instruções; Exemplo:\nif (x \u0026gt; 0){ printf(\u0026#34;O valor de x é positivo.\u0026#34;); x = x + 1; z = x; } Podemos também escrever instruções que deverão ser executadas caso a condição seja falsa. Para isso, complementamos a estrutura do IF com o ELSE. A sintaxe é: (Leia-se: SE condição for verdadeira, ENTÃO instrução_se_condição_verdadeira será executada, SE NÃO, instrução_se_condição_falsa será executada. )\nif (condição) instrução_se_condição_verdadeira; else instrução_se_condição_falsa; Por exemplo: (Leia-se: SE x for maior que zero, ENTÃO imprima na tela o texto \u0026ldquo;O valor de x é positivo\u0026rdquo;, SE NÃO, imprima na tela o texto \u0026ldquo;O valor de x é negativo ou igual a zero\u0026rdquo;. )\nif (x \u0026gt; 0) printf(\u0026#34;O valor de x é positivo.\u0026#34;); else printf(\u0026#34;O valor de x é negativo ou igual a zero.\u0026#34;); Da mesma forma, podemos criar blocos de instruções a partir do else. Por exemplo:\nif (x \u0026gt; 0){ printf(\u0026#34;O valor de x é positivo.\u0026#34;); x = x + 1; z = x; } else { printf(\u0026#34;O valor de x é negativo ou igual a zero.\u0026#34;); w = x; } É possível fazer o aninhamento da estrutura IF-ELSE.\nif (condição_01){ instrução_01; } else if (condição_02){ instrução_02; } else { instrução_03; } Exemplo:\nif (x \u0026gt; 0) { printf(\u0026#34;O valor de x é positivo.\u0026#34;); } else if (x \u0026lt; 0) { printf(\u0026#34;O valor de x é negativo.\u0026#34;); } else{ printf(\u0026#34;O valor de x é zero.\u0026#34;); } Podemos fazer quantos aninhamentos quisermos, por exemplo:\nint lados = 0; printf(\u0026#34;Digite o número de lados do seu polígono:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. if (lados == 3) { printf(\u0026#34;O polígono é um triângulo.\u0026#34;); } else if (lados == 4) { printf(\u0026#34;O polígono é um quadrilátero.\u0026#34;); } else if (lados == 5) { printf(\u0026#34;O polígono é um pentágono.\u0026#34;); } else if (lados == 6) { printf(\u0026#34;O polígono é um hexágono.\u0026#34;); } else if (lados == 7) { printf(\u0026#34;O polígono é um heptágono.\u0026#34;); } else{ printf(\u0026#34;Valor não identificado.\u0026#34;); } Como temos uma única linha de instrução para cada condição, poderíamos reescrever o código acima dessa forma:\nif (lados == 3) printf(\u0026#34;O polígono é um triângulo.\u0026#34;); else if (lados == 4) printf(\u0026#34;O polígono é um quadrilátero.\u0026#34;); else if (lados == 5) printf(\u0026#34;O polígono é um pentágono.\u0026#34;); else if (lados == 6) printf(\u0026#34;O polígono é um hexágono.\u0026#34;); else if (lados == 7) printf(\u0026#34;O polígono é um heptágono.\u0026#34;); else printf(\u0026#34;Valor não identificado.\u0026#34;); SWITCH-CASE # Blocos de códigos condicionais também podem ser criados com a estrutura SWITCH-CASE. A sintaxe é:\nswitch(variável){ case valor_1: instruções; //podem ser várias linhas de instruções break; case valor_2: instruções; break; ... case valor_m: instruções; break; default: instruções; } Vamos entender:\nA variável dentro do switch() poderá ser do tipo int ou char; O switch é composto por blocos case. Cada bloco case é um teste para saber se o valor da variável é igual ao valor declarado após o nome case (valor_1, no exemplo do primeiro bloco case). Caso seja igual, as instruções pertencentes ao bloco serão executadas. Caso seja diferente, o próximo bloco case será testado. Podemos ler a estrutura acima dessa forma: \u0026ldquo;Caso o valor de variável seja igual a valor_1, execute as instruções do primeiro bloco case, pule todas as outras, e finalize a execução do switch. Caso seja diferente: Execute o mesmo teste para os blocos case sequintes com seus respectivos valores. O último bloco é o default. Se o valor de variável for diferente de todos os valores declarados nos blocos case, as instruções do bloco default serão executadas. Esse bloco é opcional. Perceba que o último comando de cada bloco case é o break. Este comando é o responsável pelo comportamento de \u0026ldquo;pular todos os outros\u0026rdquo; blocos case após encontrar o valor correspondente em um bloco corrente. Vejamos um código exemplo de SWITCH-CASE:\nint lados = 0; printf(\u0026#34;Digite o número de lados do seu polígono:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. switch(lados){ case 3: printf(\u0026#34;O polígono é um triângulo.\u0026#34;); break; case 4: printf(\u0026#34;O polígono é um quadrilátero.\u0026#34;); break; case 5: printf(\u0026#34;O polígono é um pentágono.\u0026#34;); break; case 6: printf(\u0026#34;O polígono é um hexágono.\u0026#34;); break; case 7: printf(\u0026#34;O polígono é um heptágono.\u0026#34;); break; default: printf(\u0026#34;Valor não identificado.\u0026#34;); } Caso o usuário digite 3, o programa imprimirá na tela apenas O polígono é um triângulo.. Se o usuário digitar um valor que não está declarado em nenhum bloco case, por exemplo, 10, o programa imprimirá: Valor não identificado.\nO comando break é opcional, porém, o SWITCH-CASE funciona de forma diferente se não o utilizarmos. Após encontrar o valor correspondente em um bloco case, todos os outros blocos sequintes serão executados também. Por exemplo, considere o mesmo código sem os comandos break:\nint lados = 0; printf(\u0026#34;Digite o número de lados do seu polígono:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. switch(lados){ case 3: printf(\u0026#34;O polígono é um triângulo.\u0026#34;); case 4: printf(\u0026#34;O polígono é um quadrilátero.\u0026#34;); case 5: printf(\u0026#34;O polígono é um pentágono.\u0026#34;); case 6: printf(\u0026#34;O polígono é um hexágono.\u0026#34;); case 7: printf(\u0026#34;O polígono é um heptágono.\u0026#34;); default: printf(\u0026#34;Valor não identificado.\u0026#34;); } Neste caso, se o usuário digitar 3, o programa imprimirá na tela: O polígono é um triângulo. O polígono é um quadrilátero. O polígono é um pentágono. O polígono é um hexágono. O polígono é um heptágono. Valor não identificado..\nDa mesma forma, se o usuário digitar 5, o programa imprimirá: O polígono é um pentágono. O polígono é um hexágono. O polígono é um heptágono. Valor não identificado.\nCondição ? verdadeiro : falso # (em breve)\nComandos de repetição # As estruturas condicionais estudadas acima executam um bloco de intruções quando uma determinada condição é satisfeita. O bloco é executado apenas uma vez, e o programa prossegue executando as próximas instruções de código, caso existam. As vezes, alguns algorítmos requerem a repetição da execução do mesmo bloco de instruções enquanto uma condição continua sendo satisfeita. Para isso, utilizamos comandos de repetição. A linguagem C possui três formas de estruturas de repetição:\nfor while do while FOR # O comando for permite a repetição de um bloco de instruções enquanto uma condição for satisfeita. A sintaxe do comando for é:\nfor (variável_de_inicialização; condição; incremento){ instruções; } Vamos entender:\nvariável_de_inicialização normalmente contém a declaração e/ou a atribuição de um valor à uma variável que será utilizada como um contador de repetições. condição normalmente contém uma expressão boleana envolvendo a variável_de_inicialização. incremento normalmente contém a adição ou subtração da variável_de_inicialização. O comando for funciona da seguinte forma:\nPrimeiro a instrução em variável_de_inicalização é executada; Em seguida, a condição é testada. Se o resultado for verdadeiro, o bloco de instruções é executado. Ao final da execução do bloco, o comando em incremento é executado. Então, a condição é testada novamente, e o bloco de instruções será executado novamente caso o resultado seja verdadeiro. Executa-se o comando em incremento novamente, e a repetição entre testar condição -\u0026gt; executar bloco de instruções -\u0026gt; executar incremento continua até que a condição não seja satisfeita, ou seja, retorne falso. Um exemplo de código:\nfor (int i = 1; i \u0026lt; 5; i++){ printf(\u0026#34;Repetição %d. \u0026#34;, i); } A saída do código será:\nRepetição 1. Repetição 2. Repetição 3. Repetição 4. Outro exemplo:\nfor (int i = 4; i \u0026gt; 0; i--){ printf(\u0026#34;Repetição %d. \u0026#34;, i); } A saída do código será:\nRepetição 4. Repetição 3. Repetição 2. Repetição 1. Existem variações na estrutura do comando for, mas não trabalharemos com as variações neste momento.\nWHILE # Outra estrutura de repetição é a do comando WHILE. A sintaxe é: (Leia-se: Enquanto condição for verdadeira, execute o bloco de instruções.)\nwhile (condição) { instruções; } Com uma sintaxe mais simples, o while define a condição para que uma sequência de instruções seja executada. O comando testa a condição repetidamente após finalizar a execução de todas as instruções definidas em seu bloco (entre { }). No momento em que a condição não for mais satisfeita, o bloco de instrucões não será mais executado, e a próxima instrução no código será executada, caso exista.\nPodemos conseguir o mesmo efeito do código com a estrutura for anterior, por exemplo:\nint i = 1; while(i \u0026lt; 5) { printf(\u0026#34;Repetição %d. \u0026#34;, i); i++; } A saída do código será:\nRepetição 1. Repetição 2. Repetição 3. Repetição 4. DO WHILE # Uma estrutura semelhante à do WHILE é a DO WHILE. A sintaxe é: (Leia-se: Faça a execução do bloco de instruções, enquanto condição for verdadeira.)\ndo { instruções } while(condição) A diferença desse comando para o while anterior é que o bloco de instruções é executado a primeira vez sem que a condição seja testada. Ao final da primeira execução a condição é avaliada, e se verdadeira, o compilador retorna para o início do bloco novamente, e o mesmo ciclo de repetições acontece até que a condição não seja mais satisfeita.\nExemplo de código:\nint i = 1; do { printf(\u0026#34;Repetição %d. \u0026#34;, i); i++; } while(i \u0026lt; 5) A saída do código também será:\nRepetição 1. Repetição 2. Repetição 3. Repetição 4. Comando break # Vimos anteriormente a utilização do comando break em conjunto com o SWITCH-CASE. Porém, o comando break também pode ser utilizado dentro de blocos de intruções de estruturas de repetição. Neste caso, o comando interrompe toda a execução do laço de petição, finalizando a execução da estrutura de repetição ao qual se encontra. Por exemplo:\nint i = 1, j = 0; printf(\u0026#34;Digite um número de 1 a 4: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); while(i \u0026lt; 5) { if(i == j){ break; } printf(\u0026#34;Repetição %d. \u0026#34;, i); i++; } No código acima, incluímos uma variável j cujo valor será inserido pelo usuário na execução do programa. Incluímos, também, uma condição if dentro do while, que compara o valor da variável i com j. Caso sejam iguais, o comando break é executado, e todo o comando while será finalizado (isso inclui todas as instruções após o bloco do if).\nCaso o usuário digite 3, a saída será:\nRepetição 1. Repetição 2. Comando continue # Assim como o comando break, o comando continue pode ser utilizado dentro de blocos de instruções de estruturas de repetição. Porém, ao invés de finalizar toda a execução da estrutura de repetição, o continue finaliza apenas a execução da repetição corrente, e a próxima repetição poderá ser executada (caso a condição continue sendo verdadeira). Por exemplo:\nint i = 1, j = 0; printf(\u0026#34;Digite um número de 1 a 4: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); while(i \u0026lt; 5) { if(i == j){ i++; continue; } printf(\u0026#34;Repetição %d. \u0026#34;, i); i++; } Neste caso, se o usuário digitar 3, a saída será:\nRepetição 1. Repetição 2. Repetição 4. Observe que, na repetição à qual i assumiu o valor 3, a condição i == j passou a ser verdadeira, e o comando continue foi executado. Sendo assim, as instruções seguintes dentro do bloco while foram puladas, e a condição do while voltou a ser testada para uma nova repetição do seu bloco de instruções. Observe também que incluí o incremento da variável i dentro do bloco if. Consegue me explicar o porquê? Me conte na próxima aula!\nArrays # Até agora trabalhamos com variáveis que comportavam um único valor, por exemplo, um número ou um caractere. A linguagem também permite criarmos variáveis que comportem um conjunto de valores, como uma lista de valores. Começaremos entendendo o que são arrays.\nArrays são variáveis que representam uma lista de valores do mesmo tipo, e podemos acessar cada valor da lista indexando a variável com as posições dos elementos na lista. A sintaxe da declaração é:\ntipo nome_da_variavel[tamanho_da_lista]; Por exemplo:\nint numeros[5]; //uma variável que comporta 5 números inteiros diferentes. Conseguimos atribuir valores ou acessar cada um dos 5 números da variável numeros através de índices ordenados. Indices em arrays são números inteiros positivos, e começam do valor zero. Na declaração da variável numeros, temos 5 posições de memória que podem ser acessadas com os índices 0, 1, 2, 3 e 4. Vejamos no código:\nint numeros[5]; numeros[0] = 10; numeros[1] = 11; numeros[2] = 12; numeros[3] = 13; numeros[4] = 14; for(int i = 0; i \u0026lt; 5; i++){ printf(\u0026#34;%d \u0026#34;, numeros[i]); } No código acima, estamos primeiro atribuindo valores à cada uma das posições da variável numeros. Em seguida, estamos percorrendo toda a variável com a estrutura de repetição for para imprimir os valores de cada posição na tela. Note que, não existe a posição numeros[5], esta representaria um sexto elemento e extrapolaria o tamanho declarado da variável. A saída do programa será:\n10 11 12 13 14 Da mesma forma que fizemos com as variáveis \u0026ldquo;simples\u0026rdquo;, também podemos inicializar um array em sua declaração. Exemplo:\nint numeros[5] = {10, 11, 12, 13, 14}; for(int i = 0; i \u0026lt; 5; i++){ printf(\u0026#34;%d \u0026#34;, numeros[i]); } Atribuição # A linguagem C não permite a atribuição de arrays. Ou seja, não é possível copiar o valor de um array para outro com uma simples atribuição de variáveis. Para copiar, precisamos percorrer todo o array. Exemplo:\nint numeros_1[5] = {10, 11, 12, 13, 14}; int numeros_2[5]; //Copiar os valores de numeros_1 para numeros_2 for(int i = 0; i \u0026lt; 5; i++){ numeros_2[i] = numeros_1[i]; } //Imprimir os valores de numeros_2 for(int i = 0; i \u0026lt; 5; i++){ printf(\u0026#34;%d \u0026#34;, numeros_2[i]); } Matrizes # Arrays possuem uma única dimensão.\nEventualmente, precisamos organizar várias listas de valores associados. Para isso, podemos utilizar matrizes.\nMatrizes são arrays que podem ter várias dimensões!\nNeste curso, estudaremos as matrizes com duas dimensões. Assim como na matemática, podemos chamar a primeira dimensão de linha e a segunda de coluna. A sintaxe da declaração é:\ntipo nome_da_variável[numero_de_linhas][numero_de_colunas]; Exemplo de código:\n// Declaração de uma matriz com duas linhas linhas e três colunas int numeros[2][3]; //uma variável que comporta 6 elementos numeros[0][0] = 10; numeros[0][1] = 11; numeros[0][2] = 12; numeros[1][0] = 13; numeros[1][1] = 14; numeros[1][2] = 15; for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026#34;%d \u0026#34;, numeros[i][j]); } printf(\u0026#34;\\n\u0026#34;); } Perceba que agora precisamos usar indexadores diferentes para cada dimensão, um para acessar a posição da linha e outro para a coluna. O par de indexadores representa o acesso a um único elemento na matriz. Por exemplo, numeros[0][0] acessa o primeiro elemento da matriz, que está na linha zero e coluna zero. Da mesma forma, para percorrer a matriz e imprimir seus elementos precisamos de duas estruturas de repetição, uma para cada dimensão. Cada estrutura define um indexador diferente. No código de exemplo, utilizamos os inteiros i e j para indexar linhas e colunas, respectivamente. Perceba que acrescentei um printf(\u0026quot;\\n\u0026rdquo;) após a finalização do for que percorre as colunas. Dessa forma, após a impressão de cada coluna completa, pularemos uma linha para iniciar a impressão da próxima coluna. A saída do programa será:\n10 11 12 13 14 15 Uma matriz também pode ser inicializada em sua declaração, como fizemos com arrays. A linguagem C permite duas sintaxes diferentes, vejamos o exemplo:\n//Inicalização com todos os elementos em sequência. int numeros_1[2][3] = {10, 11, 12, 13, 14, 15}; //Inicialização com um par de {} interno para cada coluna da matriz int numeros_2[2][3] = {{10, 11, 12}, {13, 14, 15}}; printf(\u0026#34;A matriz numeros_1 é: \\n\u0026#34;); for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026#34;%d \u0026#34;, numeros_1[i][j]); } printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;\\nA matriz numeros_2 é: \\n\u0026#34;); for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026#34;%d \u0026#34;, numeros_2[i][j]); } printf(\u0026#34;\\n\u0026#34;); } No exemplo, numeros_1 e numeros_2 são duas matrizes diferentes. Utilizamos uma sintaxe de inicalização diferente para elas, mas as duas foram inicializadas com os mesmos valores. Dessa forma, na impressão da tela as duas matrizes serão iguais.\nStrings # Strings são sequências de caracteres. Em C, uma sequência de caracteres nada mais é do que um array do tipo char. Podemos criar arrays de char da mesma forma que fizemos com os outros tipos anteriormente. Além disso, aos arrays de char também podem ser atribuídos textos diretamente. Vejamos exemplos de declaração de strings:\n// Inicialização com caracteres char string_1[7] = {\u0026#39;S\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;\\0\u0026#39;}; // Inicialização com texto char string_2[7] = \u0026#34;String\u0026#34;; char string_3[7]; string_3 = \u0026#34;String\u0026#34; printf(\u0026#34;%s\u0026#34;, string_1); printf(\u0026#34;%s\u0026#34;, string_2); printf(\u0026#34;%s\u0026#34;, string_3); Os strings em C possuem um \\0 ao final para representar o final do string. Observe que na declaração de string_1 adicionamos explicitamente o \\0. Na inicialização com texto, isso já é feito pelo compilador de forma implícita. Observe, também, que devemos contabilizar esse último caractere na definição do tamanho do array.\nOutra novidade é o indicador do tipo de variável no printf, que passou a ser %s.\nLeitura de strings # Podemos utilizar o comando scanf para a leitura de strings, com a seguinte sintaxe:\nchar nome[20]; printf(\u0026#34;Digite um nome:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, nome); printf(\u0026#34;%s \u0026#34;, nome); Observe que utilizamos o %s no scanf e não adicionamos o símbolo \u0026amp; à variável associada, como fizemos na leitura de variáveis nos exemplos vistos anteriormente.\nImportante: A leitura de strings com o scanf é interrompida ao ser encontrado o primeiro espaço em branco digitado. Dessa forma, se o usuário digitar, por exemplo, Ana Maria, no nosso exemplo, apenas o Ana será atribuído à variável nome.\nAlternativamente, podemos utilizar a função gets(). Esta támbém é uma função presente na biblioteca padrão da linguagem C, e é possível ler frases inteiras com espaços em brancos. A leitura é finalizada ao ser encontrado o caractere que representa uma quebra de linha (\\n), ou seja, quando o usuário digitar enter. Vejamos exemplo:\nchar frase[20]; printf(\u0026#34;Digite uma frase:\u0026#34;); gets(frase); printf(\u0026#34;%s \u0026#34;, frase); Troubleshooting: Já presenciei alguns erros reportados pelos alunos nas aulas de laboratório, utilizando essas funções de leitura de strings. Um erro comum era o retorno de caracteres errados. Uma possível solução é realizar a limpeza da memória buffer do teclado antes de realizar a leitura. Para isso, utilizamos a função setbuf com a configuração setbuf(stdin, NULL). Exemplo:\nchar frase[20]; // Limpeza do buffer - Atribui o valor NULL à setbuf(stdin, NULL); printf(\u0026#34;Digite uma frase:\u0026#34;); gets(frase); printf(\u0026#34;%s \u0026#34;, frase); O nome stdin representa o buffer de entrada padrão do sistema, e o exemplo atribui o valor NULL a ele.\nBiblioteca \u0026lt;string.h\u0026gt; # A biblioteca padrão da linguagem C possui um conjunto de funções para manipulação de strings. Para utilizá-las, é necessário adicionar a biblioteca string.h no cabeçalho do programa:\n#include \u0026lt;string.h\u0026gt; Vejamos exemplos de funções:\nComprimento do string # A função strlen() recebe um string como parâmetro de entrada e retorna o número de caracteres não nulos do string:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char palavra[20] = \u0026#34;livro\u0026#34;; int tamanho = strlen(palavra); printf(\u0026#34;A palavra tem %d letras.\u0026#34;, tamanho); } A saída do código acima será o número de caracteres da palavra livro:\nA palavra tem 5 letras. Comparação de strings # A função strcmp() recebe dois strings como parâmetros de entrada e retorna:\n0 quando os strings são exatamente iguais. um valor diferente de 0 quando os strings são diferentes. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char palavra_1[20] = \u0026#34;livro\u0026#34;; char palavra_2[20] = \u0026#34;LIVRO\u0026#34;; int resultado_1 = strcmp(palavra_1, \u0026#34;livro\u0026#34;); //retornará zero int resultado_2 = strcmp(palavra_1, palavra_2); //retornará valor diferente de zero printf(\u0026#34;Comparação 01: %d\u0026#34;, resultado_1); printf(\u0026#34;\\n Comparação 02: %d\u0026#34;, resultado_2); } Um exemplo de saída é:\nComparação 01: 0 Comparação 02: 32 Concatenação de string # A função strcat() recebe dois strings como parâmetros de entrada e concatena o segundo string ao primeiro. Dessa forma, apenas o primeiro string é alterado. O caractere de finalização (\\n) do primeiro string é substituído pelo primeiro caractere do segundo string.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char palavra_1[20] = \u0026#34;Bons \u0026#34;; char palavra_2[20] = \u0026#34;estudos!\u0026#34;; strcat(palavra_1, palavra_2); //retornará zero printf(\u0026#34;palavra_1: %s\u0026#34;, palavra_1); } A saída será:\nBons estudos! Ponteiros # Já sabemos que as variáveis que criamos em nossos programas são armazenadas na memória do computador. Vamos entender melhor essa estrutura.\nCada posição de memória possui um endereço associado. Dessa forma, toda a estrutura de memória é organizada como pares: o endereço e o espaço reservado para armazenar algum conteúdo.\nQuando declaramos uma variável e atribuímos a ela algum valor, essa variável é associada a algum endereço de memória, e o valor que atribuímos a ela é armazenado na posição de conteúdo correspondente ao endereço alocado. A tabela abaixo traz uma ilustração (fictícia) desse conceito:\nVariável Endereço Conteúdo \u0026hellip; int x; 1000 00101011 1001 10101011 1002 01001000 1004 01001010 int z; 1005 10101001 \u0026hellip; Podemos acessar o endereço de memória associado à uma variável utilizando o operador de endereçamento \u0026amp; antes do nome da variável. Por exemplo:\n#include \u0026lt;stdio.h\u0026gt; int main(){ int varInt; printf(\u0026#34;Endereço de memória de varInt: %p\u0026#34;, \u0026amp;varInt); return 0; } Um exemplo de saída é:\nEndereço de memória de varInt: 0x7ff7bdc9f3c8 Endereços de memória podem ser visualizados como decimais ou hexadecimais. Utilizamos a sequência de caracteres %p para representar o endereço em hexadecimal.\nPonteiros são formas especiais de variáveis que armazenam endereços de memória. A sintaxe de declaração de um ponteiro é:\ntipo *nome_da_variavel; Por exemplo:\nint *pointInt; // um ponteiro que pode \u0026#34;apontar\u0026#34; para uma variável do tipo int float *pointFloat; // um ponteiro que pode \u0026#34;apontar\u0026#34; para uma variável do tipo float Acrescentamos à declaração da variável o símbolo * para informar que a variável é um ponteiro. Ao armazenar um endereço de memória de alguma variável X, dizemos que o ponteiro \u0026ldquo;aponta\u0026rdquo; para essa variável X. Vejamos um exemplo:\n#include \u0026lt;stdio.h\u0026gt; int main(){ int varInt = 10; int *pointInt; // declaração do ponteiro pointInt = \u0026amp;varInt; // inicialização do ponteiro printf(\u0026#34;varInt: %d\u0026#34;, varInt); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;pointInt: %d\u0026#34;, *pointInt); //acesso ao valor \u0026#34;apontado\u0026#34; return 0; } A saída do programa é:\nvarInt: 10 pointInt: 10 Vamos entender:\nvarInt é uma variável do tipo inteiro, inicalizada com o conteúdo 10. pointInt é um ponteiro que poderá apontar para uma variável do tipo inteiro. O comando pointInt = \u0026amp;varInt atribui o endereço de varInt à variável pointInt. Lembre-se, ponteiros armazenam endereços de memória. Ou seja, pointInt está \u0026ldquo;apontando\u0026rdquo; para varInt. Sendo assim, podemos acessar o valor de varInt através do seu ponteiro pointInt. A sintaxe para acesso é: *pointInt. Em resumo,\npointInt armazena um endereço de memória, e *pointInt acessa o conteúdo que está armazenado nesse endereço. Vejamos um código mais detalhado:\n#include \u0026lt;stdio.h\u0026gt; int main(){ int varInt = 10; int *pointInt = NULL; //ponteiro inicializado com valor nulo. printf(\u0026#34;Variável varInt:\u0026#34;); printf(\u0026#34;\\n - Endereço de memoria: (em hexadecimal) %p (em decimal) %d\u0026#34;, \u0026amp;varInt, \u0026amp;varInt); printf(\u0026#34;\\n - Valor armazenado: %d\\n\\n\u0026#34;, varInt); pointInt = \u0026amp;varInt; // o endereço de memória de varInt será o conteúdo de pointInt. printf(\u0026#34;Variável pointInt:\u0026#34;); printf(\u0026#34;\\n - Endereço de memoria: (em hexadecimal) %p (em decimal) %d\u0026#34;, \u0026amp;pointInt, \u0026amp;pointInt); printf(\u0026#34;\\n - Valor armazenado: (em hexadecimal) %p (em decimal) %d\u0026#34;, pointInt, pointInt); printf(\u0026#34;\\n - Conteudo da posicao apontada: %d \\n\u0026#34;, *pointInt); return 0; } Um exemplo de saída é:\nVariável varInt: - Endereço de memoria: (em hexadecimal) 0x7ff7bf0a93c8 (em decimal) -1089825848 - Valor armazenado: 10 Variável pointInt: - Endereço de memoria: (em hexadecimal) 0x7ff7bf0a93c0 (em decimal) -1089825856 - Valor armazenado: (em hexadecimal) 0x7ff7bf0a93c8 (em decimal) -1089825848 - Conteudo da posicao apontada: 10 Aritmética de ponteiros # A aritmética de ponteiros refere-se às operações matemáticas que você pode realizar com ponteiros. Essas operações são baseadas no tipo de dado para o qual o ponteiro está apontando. A linguagem C permite adição e subtração entre ponteiros e inteiros, e permite a subtração entre ponteiros entre si.\nPor exemplo, se você tem um ponteiro p e o incrementa com 3 (p + 3), você obterá o avanço de três blocos de memória do tipo ao qual o ponteiro está apontando. Vejamos.\nConsidere o ponteiro p:\nint *p; A expressão de adição\np + 3 é válida. Signica que você terá acesso ao endereço da posição de memória que está três objetos adiante do endereço do objeto para o qual p aponta. Como p é um endereço, p + 3 também resultará em um endereço. O compilador ajustará o endereço de acordo com o tamanho do tipo. Isso é feito multiplicando o valor a ser adicionado pelo tamanho do tipo de dado para o qual p aponta.\nPor exemplo, se o endereço atual contido em p é 1000, e considerando que o tipo int ocupa 4 bytes, então, p + 3 significa 1000 + 3*4, que é igual ao endereço 1012.\nPor outro lado, se p fosse um ponteiro para char, com a declaração *char p, então p + 3 significaria 1003.\nPortanto, p + 3 sempre significa o endereço do terceiro objeto após p, independentemente do tipo de objeto para o qual p aponta.\nSeguem exemplos de expressões legais e ilegais utilizando aritmética de ponteiros:\nint *p1, *p2; char * p3; long j; //EXPRESSÕES VÁLIDAS p1++; // Avança para o próximo elemento int p2--; // Retrocede um elemento int p3 = p3 + 5; // Avança 5 bytes a partir do endereço de p3 p1 = p1 - 2; // Retrocede 2 elementos int p1 = p1 + 3; // Avança 3 elementos int (supondo que p1 é para int) j = p2 - p1; // Calcula o número de elementos int entre p1 e p2 //EXPRESSÕES ILEGAIS p3 = p1 + 2; // Ilegal: ponteiros para tipos diferentes p1 = p3 - 1; // Ilegal: ponteiros para tipos diferentes j = p3 - p2; // Ilegal: ponteiros para tipos diferentes p1 = p1 + p2; // Ilegal: não é permitido adicionar dois ponteiros p3 = p1 - p2; // Ilegal: resultado da subtração de ponteiros não pode ser usado como um ponteiro Aritmética de ponteiros é especialmente útil quando você está trabalhando com arrays, pois um array é basicamente um bloco contíguo de memória que armazena uma sequência de elementos do mesmo tipo. A seguir, veremos a relação entre ponteiros e arrays, e como podemos utilizar aritmética de ponteiros para manipulação de arrays.\nRelação entre ponteiros e arrays # Em C, arrays e ponteiros estão intimamente relacionados. Quando você usa o nome de um array em uma expressão, ele é convertido para um ponteiro para o seu primeiro elemento.\nPor exemplo, considere o seguinte array:\nint numeros[5] = {1, 2, 3, 4, 5}; Aqui, numeros é o nome do array, mas em muitas expressões, é tratado como um ponteiro para o primeiro elemento do array.\nIsso significa que numeros é equivalente a \u0026amp;numeros[0]. Portanto, se você fizer:\nint numeros[5] = {1, 2, 3, 4, 5}; int *p = numeros; // p aponta para arr[0] printf(\u0026#34;%d \u0026#34;, *p); //imprime o conteúdo de numero[0] printf(\u0026#34;\\n%d \u0026#34;, numeros[0]); //também, imprime o mesmo conteúdo A saída do código será:\n1 1 No exemplo acima, p é um ponteiro que aponta para o primeiro elemento de numeros. Você pode acessar os elementos do array usando esse ponteiro da mesma forma que acessaria os elementos do array diretamente, utilizando aritmética de ponteiros. Exemplo:\nint numeros[5] = {1, 2, 3, 4, 5}; int *p = numeros; // p aponta para arr[0] printf(\u0026#34;%d\\n\u0026#34;, *(p + 2)); // Imprime o terceiro elemento do array, que é 3 A saída do código será:\n3 Segue outro exemplo de manipulação de array utilizando ponteiros:\n#include \u0026lt;stdio.h\u0026gt; int main() { int array[5] = {10, 20, 30, 40, 50}; // Declaração e inicialização do array int *ptr = array; // Ponteiro que aponta para o início do array // Acesso e impressão dos elementos usando aritmética de ponteiro for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;Elemento %d: %d\\n\u0026#34;, i, *(ptr + i)); } return 0; } Funções # Podemos organizar o código em blocos que delimitam um escopo próprio para a realização de uma tarefa específica, e que podem ser reaproveitados em diferentes pontos do código. Fazemos isso através de funções. A sintaxe da declaração de uma função é:\ntipo_de_retorno nome_da_função(tipo_de_parametro_de_entrada nome_parametro_de_entrada){ instruções; return valor_de_retorno; } Vamos entender\nUma função pode receber parâmetros de entrada para utilizar os valores dos parâmetros na realização de alguma tarefa. Para especificar um parâmetro de entrada da função, devemos declarar o seu tipo em tipo_de_parametro_de_entrada seguido do nome que utilizaremos para acessar o parâmetro dentro da função, declarado em nome_parametro_de_entrada.\nParâmetros de entrada são opcionais. Podemos ter vários parâmetros de entrada separados por vírgula, cada um com sua declaração completa (tipo e nome). Uma função pode retornar algum valor, e definimos o tipo do valor na sua declaração em tipo_de_retorno. Neste caso, após realizar sua atividade, a função deverá retornar um valor do tipo declado utilizando a palavra reservada return.\nCaso a função não precise retornar valor algum, utilizamos a palavra void na declaração, e o return será desnecessário. Podemos utilizar return em qualquer ponto do corpo da função. Acessaremos a função através do seu nome, declarado em nome_da_função.\nVejamos exemplos:\n#include \u0026lt;stdio.h\u0026gt; // Função sem parâmetros de entrada e sem retorno. void funcao_1(){ printf(\u0026#34;Execução da função 1.\\n\u0026#34;); } // Função com dois parâmetros de entrada, e que retorna um número inteiro. int funcao_2(int a, int b){ printf(\u0026#34;\\nExecução da função 2, com os valores de entrada %d e %d.\\n\u0026#34;, a, b); return a+b; } int main(){ printf(\u0026#34;Iniciando a execução do programa.\\n\u0026#34;); funcao_1(); //Instanciando funcao_1 int valor = funcao_2(1, 2); //Instanciando funcao_2 printf(\u0026#34;A soma de 1 e 2 é %d\u0026#34;, valor); //Instanciando funcao_2 novamente printf(\u0026#34;A soma de 10 e 11 é %d\u0026#34;, funcao_2(10, 11)); return 0; } Vamos entender:\nO código começa a ser executado no escopo principal main(), e toda vez que há a chamada de uma função, o fluxo de execução \u0026ldquo;pula\u0026rdquo; para o escopo da função e executa todo o código da função. Ao finalizar a execução da função, o fluxo de execução do programa retorna para o escopo main() e a próxima linha de código após a chamada da função é executada.\nAs funções são declaradas antes de serem chamadas. Perceba que elas foram declaradas antes do inicio do escopo main().\nfuncao_1() é a forma que chamamos funcao_1 para ser executada.\nA funcao_2 possui dois parâmetros de entrada, dessa forma precisamos passar valores de tipos equivalentes na sua chamada. Na chamada funcao_2(1, 2) passamos os valores 1 e 2, que serão atribuídos aos parâmetros a e b da função.\nNas chamadas de funcao_2 do código acima, passamos valores diretamente para serem atribuídos aos parâmetros de entrada da função. Poderíamos, também, passar variáveis como parâmetros. Neste caso, os valores atribuídos previamente às variáveis serão copiados para os parâmetros de entrada da função. Em C, chamamos esse comportamento de passagem de parâmetro por valor. Vejamos um exemplo:\n#include \u0026lt;stdio.h\u0026gt; // Função com um parâmetro de entrada, e que retorna um número fracionado. float funcao_3(int num){ float resultado; if(num == 0){ return 0; } resultado = 10 / num; return resultado; } int main(){ int numero = 10; float resultado = funcao_3(numero); printf(\u0026#34;A função 3 teve como retorno o valor: %f\u0026#34;, resultado ); } No exemplo, a variável numero foi inicalizada com o valor 10, e passamos a variável como parâmetro da chamada de funcao_3. Isso quer dizer que o valor 10 será copiado para o parâmetro de entrada num da função.\nA passagem de parâmetros por valor é o comportamento padrão quando passamos variáveis como parâmetros de entrada de funções. Na passagem por valor, o conteúdo da variável é copiado para a função, e a função não terá acesso à variável.\nExiste outra forma de passar parâmetros para as funções, chamada de passagem por referência.\nQuando desejamos que uma função tenha acesso direto à variável, podendo alterar seu conteúdo, devemos utilizar a passagem de parâmetros por referência. Utilizarmos ponteiros para implementar a passagem por referência.\nA forma de implementar é:\nNa declaração da função, o parâmetro de entrada deverá ser declarado como um ponteiro. Ao operar com a variável dentro da função, devemos lembrar de utilizar o ponteiro para o conteúdo apontado (ex. *pointInt). Na chamada da função, devemos passar o endereço de memória da variável que queremos passar como parâmetro. Vejamos um exemplo:\n#include \u0026lt;stdio.h\u0026gt; // 1. Declaramos os parâmetros de entrada da função como ponteiros void funcao_passagem_referencia(int *a, int *b){ *a += 1; // 2. Utilizamos o ponteiro para o conteúdo apontado *b -= 1; } int main(){ int x = 10, y = 10; printf(\u0026#34;Valores antes da chamada da função: x = %d e y = %d\u0026#34;, x,y); funcao_passagem_referencia(\u0026amp;x, \u0026amp;y); // 3. Passamos os endereços de memória printf(\u0026#34;\\nValores após a chamada da função: x = %d e y = %d\u0026#34;, x,y); return 0; } A saída do programa será:\nValores antes da chamada da função: x = 10 e y = 10 Valores após a chamada da função: x = 11 e y = 9 Os valores de x e y foram modificados. Uma função com passagem de parâmetros por valor não alteraria os valores de x e y. Vejamos um exemplo equivalente:\n#include \u0026lt;stdio.h\u0026gt; void funcao_passagem_valor(int a, int b){ a += 1; b -= 1; } int main(){ int x = 10, y = 10; printf(\u0026#34;Valores antes da chamada da função: x = %d e y = %d\u0026#34;, x,y); funcao_passagem_valor(x, y); printf(\u0026#34;\\nValores após a chamada da função: x = %d e y = %d\u0026#34;, x,y); return 0; } A saída do programa será:\nValores antes da chamada da função: x = 10 e y = 10 Valores após a chamada da função: x = 10 e y = 10 Mais sobre variáveis # Modificadores # Na linguagem C, modificadores de variáveis são palavras reservadas que alteram a forma como as variáveis são armazenadas e tratadas pelo compilador. Eles permitem especificar características adicionais para variáveis. Vamos explorar os principais modificadores de variáveis em C:\nsigned e unsigned # signed: Indica que uma variável pode armazenar valores positivos e negativos. O modificador signed é o padrão para variáveis caso o mofificador não seja espeficicado. Podem ser utilizados para mofificar os tipos int e char.\nunsigned: Indica que uma variável só pode armazenar valores positivos e zero. É frequentemente usado para variáveis que não precisam representar números negativos, como contadores.\nA qualificação de um tipo é feita antepondo-se o qualificador ao nome do tipo. Por exemplo:\nsigned int num_01 = -10; // Permite valores negativos e positivos unsigned int num_02 = 10; // Apenas valores não negativos short e long # short: Utilizado para reduzir o tamanho da variável. Em muitos sistemas, um short é um int de 16 bits.\nlong: Utilizado para aumentar o tamanho da variável. Em muitos sistemas, um long é um int de 32 bits ou 64 bits, dependendo da arquitetura.\nExemplo:\nshort int num_01 = -10; // Tipicamente 16 bits long int num_02 = 10; // Tipicamente 32 bits ou 64 bits A tabela a seguir apresenta intervalos típicos de valores dos tipos atitméticos.\nTipo Tamanho (em bytes) Intervalo de Valores int 4 -2ˆ31 a 2ˆ31 - 1 short int 2 -2ˆ15 a 2ˆ15 - 1 long int 4 -2ˆ31 a 2ˆ31 - 1 unsigned int 4 0 a 2ˆ32 - 1 unsigned short int 2 0 a 2ˆ16 - 1 unsigned long int 4 0 a 2ˆ32 - 1 signed char 1 -2ˆ7 a 2ˆ7 - 1 unsigned char 1 0 a 2ˆ8 - 1 A seguir, mais um exemplo de utilização de modificadores de tipos de variáveis. Observe que, para imprimir a variável unsigned, utilizamos o %u ao invés de %d.\n#include \u0026lt;stdio.h\u0026gt; int main() { unsigned int u = 4294967295; // O maior valor que um unsigned int pode armazenar signed int s = -2147483648; // O menor valor que um signed int pode armazenar short int si = 32767; // O maior valor que um short int pode armazenar printf(\u0026#34;unsigned int: %u\\n\u0026#34;, u); printf(\u0026#34;signed int: %d\\n\u0026#34;, s); printf(\u0026#34;short int: %d\\n\u0026#34;, si); return 0; } long long # O modificador long long em C é utilizado para declarar variáveis inteiras que necessitam de uma maior capacidade de armazenamento em comparação com os tipos de dados inteiros padrão. É uma extensão do tipo long e é garantido que tenha pelo menos 64 bits de largura. Exemplo:\nlong long int bigNumber = 9223372036854775807; // Maior capacidade de armazenamento para valores inteiros long long int bigNumber_2 = 9223372036854775807LL; // Adicionamos um sufixo LL unsigned long long int bigUnsignedNumber = 18446744073709551615ULL; // Valor máximo para unsigned long long printf(\u0026#34;Signed long long: %lld\\n\u0026#34;, bigNumber_2); printf(\u0026#34;Unsigned long long: %llu\\n\u0026#34;, bigUnsignedNumber); No exemplo, adicionamos os sufixos LL e ULL ao valor das variáveis para garantir que o valor literal seja tratado como long long e unsigned long long, respectivamente.\nObserve, também, que utilizamos especificadores de formato apropriados para imprimir as variáveis:\n%lld para signed long long %llu para unsigned long long volative # (em breve)\nEnumerações # Uma enumeração é um tipo de dado definido pelo usuário que consiste em um conjunto de constantes inteiras nomeadas. Elas são úteis para representar um grupo de valores relacionados de forma legível e organizada.\nDefinimos uma enumeração usando a palavra reservada enum, seguida por um nome para a enumeração e uma lista de identificadores (nomes) para os valores possíveis. Vejamos um exemplo:\nenum DiaDaSemana { DOMINGO, // 0 SEGUNDA, // 1 TERCA, // 2 QUARTA, // 3 QUINTA, // 4 SEXTA, // 5 SABADO // 6 }; Neste exemplo, enum DiaDaSemana define uma enumeração chamada DiaDaSemana com sete valores possíveis. Por padrão, o primeiro valor (DOMINGO) é associado ao número 0, o segundo (SEGUNDA) é 1, e assim por diante.\nTambém é possível atribuir valores explícitos para os elementos da enumeração. Por exemplo:\nenum Status { PENDENTE = 1, EM_ANDAMENTO = 2, CONCLUIDO = 3 }; Se o valor de uma dada constante na enumeração não for definido explicitamente, seu valor será o valor da constante anterior na seqüência acrescido de 1.\nVejamos um exemplo completo de utilização da enumeração:\n#include \u0026lt;stdio.h\u0026gt; enum DiaDaSemana { DOMINGO, SEGUNDA, TERCA, QUARTA, QUINTA, SEXTA, SABADO }; int main() { enum DiaDaSemana hoje = DOMINGO; if (hoje == DOMINGO) { printf(\u0026#34;Hoje é domingo.\\n\u0026#34;); } else { printf(\u0026#34;Hoje não é doming.\\n\u0026#34;); } return 0; } Perceba que a variável hoje é do tipo enum DiaDaSemana e a ela é atribuído o valor DOMINGO. O que aconteceria se atribuíssemos um valor diferente dos valores definidos na enumeração? Faça alterações no código para testar.\nConstantes # Até agora estudamos variáveis que poderiam ser alteradas em diferentes pontos do código após a sua declaração. A linguagem também permite a definição de valores constantes, isto é, que não podem ser alterados durante a execução do programa. Constantes são úteis para representar dados fixos e imutáveis de maneira eficiente, evitando redundâncias no código.\nConstantes definidas com const # O modificador const pode ser usado para definir variáveis que não podem ser alteradas após sua inicialização. Isso cria uma constante com verificação de tipo pelo compilador:\nconst int max_value = 100; // max_value não pode ser alterado após ser definido const float taxaImposto = 0.15; Segue exemplo de utilização:\n#include \u0026lt;stdio.h\u0026gt; const float taxaDesconto = 0.10; int main() { float precoOriginal = 100.0; float desconto = precoOriginal * taxaDesconto; printf(\u0026#34;Desconto: %.2f\\n\u0026#34;, desconto); // Tentativa de modificar a constante // taxaDesconto = 0.15; // Isso causaria um erro de compilação return 0; } Constantes simbólicas com #define # Também é possível definir valores constantes utilizando #define. Essa é uma diretiva de pré-processador que permite definir constantes que são substituídas por valores fixos durante a compilação. Ou seja, quando você usa #define, o pré-processador do compilador substitui todas as ocorrências do identificador pelo valor associado antes da compilação do código. Não é necessário especificar o tipo da constante:\n#define PI 3.14159 #define MAX_VALUE 100 #define ABC \u0026#34;ABCDE!\u0026#34; As regras para nomeação de constantes simbólicas são as mesmas utilizadas para variáveis, mas sugere-se que o programador adote uma notação diferente da utilizada em nomes de variáveis. Por esta razão, os nomes de constantes são normalmente escritos em letras maiúsculas.\nSegue exemplo de utilização:\n#include \u0026lt;stdio.h\u0026gt; // Definições de constantes usando #define #define PI 3.14159 #define RAIO_MAXIMO 10 int main() { // Cálculo da área de um círculo com raio máximo float area = PI * RAIO_MAXIMO * RAIO_MAXIMO; printf(\u0026#34;Área do círculo com raio %d: %.2f\\n\u0026#34;, RAIO_MAXIMO, area); return 0; } Tipos definidos pelo programador # Escopo de variáveis # Mais sobre operadores # Conversões # Operador sizeof # "},{"id":4,"href":"/docs/03-c-course/","title":"Introdução à Programação com a Linguagem C","section":"Docs","content":" Introdução à Programação com a Linguagem C # Programação é o método que utilizamos para criar sistemas computacionais, como jogos, websites, aplicativos de celular, e todos os sistemas de computador que encontramos em bancos, farmácias e supermercados.\nProgramar é a tarefa de se comunicar com o computador através da escrita de uma sequência de tarefas (instruções) que desejamos que seja executada. Toda comunicação requer uma linguagem comum entre as entidades que se comunicam, neste caso entre o humano (o programador) e o computador. Dessa forma, aprenderemos uma linguagem de programação para nos comunicarmos com o computador.\nA linguagem C # C é uma linguagem de propósito geral. Isso quer dizer que ela pode ser utilizada para escrever programas para várias àreas diferentes. Sua linguagem segue um padrão procedural, permitindo a decomposição de problemas grande e complexos em procedimentos (módulos) separados e mais simples.\nComo toda linguagem de programação, C possui um conjuto de palavras reservadas que são utilizadas para a criação das instruções que comporão um programa. Essa é uma lista de palavras reservadas em C:\n(Fonte: C11 – Draft version (N1570) - http://port70.net/~nsz/c/c11/n1570.html)\nPrimeiro programa em C # Agora vamos executar o primeiro código em C. Ao ser executado, o programa irá imprimir na tela a mensagem \u0026ldquo;Olá, mundo lindo!\u0026rdquo;. Digite o seguinte texto (código-fonte) em um arquivo chamado primeiro_programa.c:\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Olá, mundo lindo!\u0026#34;); return 0; } Vamos entender:\nVocê criará muitos arquivos com códigos em C daqui pra frente, e existem regras para a nomeação desses arquivos. As regras são:\nO arquivo deve ter a extensão .c. Não podem haver espaços no nome do arquivo. Por exemplo: \u0026ldquo;primeiro programa.c\u0026rdquo;. A maioria dos arquivos começará com instruções #include \u0026lt; \u0026hellip; \u0026gt;, chamadas de cabeçalho do programa. #include é uma instrução utilizada para adicionarmos procedimentos (funções) que já foram programados previamente. No exemplo, estamos adicionando ao nosso programa um arquivo presente no compilador C que foi instalado na sua máquina. O arquivo stdio.h contém código C (entederemos mais à frente a extensão .h) com procedimentos que permitem a entrada e saída de textos na tela. stdio é uma abreviação de \u0026ldquo;standard input/output\u0026rdquo;.\nint main (){ \u0026hellip; } é uma sintaxe mandatória que identifica o ponto inicial de execução do seu código. Quando executado, o seu programa começará a executar as instruções criadas dentro desse bloco delimitado pelas chaves { }. Entenderemos melhor essa estrutura quando estudarmos a declaração de funções em C. No exemplo, temos duas instruções dentro do bloco main:\nprintf é uma função definida no arquivo stdio.h para impressão de textos na tela. O texto que será impresso deve ser colocado entre aspas. return é uma palavra reservada utilizada para finalizar a execução de um bloco de código. Mais um exemplo de código:\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Programação requer prática. \\n Pratique!\u0026#34;); printf(\u0026#34;\\n Pratique!\u0026#34;); return 0; } Neste exemplo acrescentamos ao texto dentro do printf uma sequência de escape. Perceba que tem um \\n no meio do texto do primeiro printf, e no inicio do texto do segundo printf. Sequências de escape são utilizados em textos para a inserção de caracteres especiais. O \\n representa quebra de linha, como um enter do teclado. Dessa forma, a saída do programa será:\nProgramação requer prática. Pratique! Pratique! Básico da Linguagem C # Estudaremos primeiro o que considero funcionalidades básicas da linguagem.\nComentários # Além de instruções, o seu programa pode conter comentários para auxiliar o entendimento do código. É uma boa prática de programação documentar o seu código com comentários informativos e instrutivos para auxiliar a manutenção do código. Existem dois tipos de comentários em C: de linha e de bloco. Ambos são ignorados pelo compilador na criação do arquivo executável do programa.\nO comentário de linha se inicia com duas barras (//) e seu escopo finaliza ao final de uma linha:\n//Este é um comentário de linha. //Este é outro comentário de linha. O comentário de bloco é delimitado pelos símbolos /* para abertura e */ para fechamento do bloco. Todas as linhas dentro do bloco fazem parte do mesmo comentário.\n/* Este é um comentário de bloco */ /* Este também é um comentário de bloco */ Ponto e vírgula # C utiliza ponto e vírgula como delimitador de instruções. É a forma que o compilador utiliza para saber como ler e separar as instruções no código. Note que, no nosso exemplo, temos duas instruções que são finalizadas com ponto e vírgula:\nprintf(\u0026#34;Olá, mundo lindo!\u0026#34;); return 0; Algumas instruções já possuem o próprio delimitador, e não precisam de ponto e vírgula. Será fácil identificá-las quando você avançar no curso.\nVariáveis # Os dados que criamos e manipulamos em nosso programa precisam ser armazenados na memória do computador para que possam ser referenciados e utilizados no código. Linguagens de programação utilizam variáveis para este propósito. Em C, uma variável deve ser declarada no código com o seu tipo e um nome.\n//Sintaxe de instrução para criação de variável tipo nome; Os tipos são convenções definidas na linguagem, para que o compilador saiba a quantidade de memória máxima que será reservada para armazenar dados na variável. Os tipos básicos em C são:\nTipo Tamanho Descrição char 8 bits Armazena códigos correspondentes a um caractere da tabela ASCII. int 16 bits ou 32 bits Armazena números inteiros (positivos e negativos). float 32 bits Armazena números fracionários, com precisão de até sete dígitos. double 64 bits Armazena números fracionários, com precisão de até 15 dígitos. Estudaremos mais sobre os tipos de variáveis e como podem ser modificados ao longo do curso.\nExemplo de declaração de variáveis de cada tipo:\nint x; float y; char z; double k; Variáveis do mesmo tipo podem ser declaradas na mesma linha, separadas por vírgula. Exemplo:\nint x, w, q; //declaração de três variáveis do tipo int O nome da variável pode ser utilizado em diferentes partes do código para acessarmos o conteúdo presente na posição de memória correspondente.\nExistem regras para a nomeação das variáveis. São estas:\nPodem utilizar letras maiúsculas, letras minúsculas, números e o caractere sublinhado; Não podem ser iniciados com números; Não podem ser idênticos às palavras reservadas da linguagem. Exemplos de nomes válidos e inválidos:\n//Exemplos de nomes válidos int nomeValido01; float nome_valido_02; char _nomeValido_03; //Exemplos de nomes inválidos int int; int 2nome_invalido; Operador de atribuição # Como na matemática, atribuimos valor às variáveis com o símbolo de atribuição =. Podemos atribuir valor à uma variável em sua declaração, ou em outras partes do código após a sua declaração. Exemplos:\n//Atribuição de valores em conjunto com a declaração da variável int x = 10; //leia-se: x recebe o valor 10 float y = 10.123; char z = \u0026#39;a\u0026#39;; //Atribuição de valores após a criação das variáveis x = 12; z = 15.0; z = \u0026#39;b\u0026#39;; Podemos atribuir valor à mesma variável quantas vezes quisermos no mesmo programa, o valor da variável sempre é apagado da memória e substituído pelo valor mais recente que for atribuído.\nUma variável também pode receber o valor de outra variável na atribuição, por exemplo:\nint x, y; x = 10; y = x; // Atribuímos o valor 10 da variável x à variável y. Equivale à y = 10; Podemos também concatenar as atribuições de valores, por exemplo:\n//Atribuição na declaração concatenada de variáveis do mesmo tipo int x = 1, y = 2, z = 3; //Atribuição do mesmo valor à mais de uma variável. x = y = z = 4; Ao tipo char podem ser atribuídos o caractere envolto em aspas simples, como nos exemplos acima, ou o número inteiro correspondente da tabela ASCII. Exemplo:\nz = \u0026#39;c\u0026#39;; z = 99; //Na tabela ASCII, 99 é o valor decimal do caractere c. Lendo e imprimindo valores de variáveis # Nós já aprendemos a imprimir textos na tela com o comando printf(). Também utilizamos o printf() para imprimir valores de variáveis. Para isso, o comando requer a sinalização do tipo de variável que será impressa. A linguagem C utiliza uma sequência de caracteres para fazer essa sinalização, e cada tipo de variável tem um sinalizador diferente. Exemplos de sequências são:\nCaracteres Tipo de variável %d int %f float %c char Exemplos de comandos com impressão de variáveis:\nint var_int = 10; float var_float = 10.5; char var_char = \u0026#39;A\u0026#39;; printf(\u0026#34;%d\u0026#34;, var_int); printf(\u0026#34;%f\u0026#34;, var_float); printf(\u0026#34;%c\u0026#34;, var_char); Podemos concatenar valores de variáveis com textos que serão impressos na tela. Por exemplo:\nint var_int = 10; float var_float = 10.5; char var_char = \u0026#39;A\u0026#39;; printf(\u0026#34;O valor da variável tipo int é: %d.\u0026#34;, var_int); printf(\u0026#34;O valor %f pertence à variável do tipo float.\u0026#34;, var_float); printf(\u0026#34;%c é o conteúdo da variável var_char.\u0026#34;, var_char); printf(\u0026#34;Os valores das variáveis são: %d, %f, %c\u0026#34;, var_int, var_float, var_char); Para permitir que o usuário insira valores no programa, podemos ler informações digitadas no teclado com o comando scanf(). Seguem exemplos de utilização:\nint var_int; float var_float; char var_char; printf(\u0026#34;Digite um valor inteiro:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;var_int); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026#34;Digite um valor fracionado:\u0026#34;); scanf(\u0026#34;%f\u0026#34;, \u0026amp;var_float); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026#34;Digite um caractere:\u0026#34;); scanf(\u0026#34;%c\u0026#34;, \u0026amp;var_char); // Observe que adicionamos \u0026amp; ao nome da variável! printf(\u0026#34;Os valores digitados são: %d, %f, %c\u0026#34;, var_int, var_float, var_char); Assim como o printf, o scanf é uma função definida na biblioteca padrão da linguagem C, presente no arquivo stdio.h.\nOperadores aritméticos binários # Variáveis numéricas podem compor expressões aritméticas no código. Os operadores aplicados em C são:\nOperador Descrição Exemplo + soma z = x + y; - subtração z = x - y; * multiplicação z = x + y; / divisão z = x / y; % resto da divisão z = x % y; Da mesma forma que na matemática, a multiplicação e a divisão têm precedência à soma e à subtração. Para entender a execução de expressões com operadores de mesma precedência, saiba que a linguagem executará as operações da esquerda para a direita. Os parênteses também podem ser utilizados para organização de precedência na execução.\nOs operadores exemplificados acima são binários. Isto quer dizer que requerem dois elementos para realizar a operação. Nos exemplos da tabela temos x e y. Outros exemplos válidos são:\ny = 1 + 2; x = x + x; x = x - 1; z = 10 * y; Operadores aritméticos unários # Os operadores de adição e subtração também podem ser utilizados com uma única variável para incremento ou decremento do valor da variável. Neste caso, dizemos que o operador é unário. A sintaxe é diferente, pois duplicamos o operador. Veja os exemplos:\nx++; // equivale a x = x + 1; y--; // equivale a y = y - 1; Nos exemplos acima, o novo valor da variável será acessível a partir da próxima linha de código. Existe ainda a possibilidade de anteciparmos o acesso ao novo valor para a mesma linha da instrução que altera a variável. Para isso, mudamos a ordem dos operadores para:\n++x; // também incrementa 1 ao valor de x; --y; // também decrementa 1 ao valor de y; O operador de subtração também pode ser utilizado de forma unária para a declaração de números negativos. Exemplo:\nx = -1; y = - 10; Operadores relacionais # Operadores relacionais são utilizados para formar expressões que comparam dois ou mais elementos, para obter o resultado verdadeiro ou falso. Os operadores relacionais em C são:\nOperador Descrição Exemplo \u0026gt; maior que x \u0026gt; y \u0026lt; menor que x \u0026lt; y \u0026gt;= maior ou igual x \u0026gt;= y \u0026lt;= menor ou igual x \u0026lt;= y == igual a x == y != diferente de x != y Em C, as expressões relacionais retornam o valor 0 para informar que a expressão é falsa, e o valor 1 se o resultado da expressão for verdadeiro. Por exemplo:\nint x = 1, y = 2, z; z = x \u0026lt; y; // z recebe o valor 1, pois a expressão (1 é menor que 2) é verdadeira z = x == y; // z recebe o valor 0, pois a expressão (1 é igual a 2) é falsa Operadores lógicos # A lógica boleana é frequentemente utilizada quando programamos. Com a lógica boleana, podemos compor expressões utilizando os operadores binários E e OU, e o operador unário de negação NÃO. Os resultados das expressões serão sempre verdadeiros ou falsos. A semântica dos operadores está resumida nas tabelas abaixo:\nTabela do operador E (Lemos assim: verdadeiro e verdadeiro, é igual a verdadeiro):\nOperando Operador Operando Resultado verdadeiro E verdadeiro verdadeiro verdadeiro E falso falso falso E verdadeiro falso falso E falso falso Tabela do operador OU:\nOperando Operador Operando Resultado verdadeiro OU verdadeiro verdadeiro verdadeiro OU falso verdadeiro falso OU verdadeiro verdadeiro falso OU falso falso A tabela do operador de negação é mais simples. Vamos inverter a ordem do operador, para ler assim: \u0026ldquo;Não verdadeiro, é igual a falso.\u0026rdquo;:\nOperador Operando Resultado NÃO verdadeiro falso NÃO falso verdadeiro Em C, a sintaxe dos operadores boleanos E e OU é, respectivamente, \u0026amp;\u0026amp; e ||. A sintaxe do operador NÃO é o símbolo de exclamação !. Lembremos que, como resultado de expressões, o 0 representa falso e 1 representa verdadeiro. Dessa forma, utilizando a sintaxe em C, as tabelas são:\nOperador \u0026amp;\u0026amp; (E):\nOperando Operador Operando Resultado 1 \u0026amp;\u0026amp; 1 1 1 \u0026amp;\u0026amp; 0 0 0 \u0026amp;\u0026amp; 0 0 0 \u0026amp;\u0026amp; 0 0 Operador || (OU):\nOperando Operador Operando Resultado 1 || 1 1 1 || 0 1 0 || 0 1 0 || 0 0 Operador de negação ! :\nOperador Operando Resultado ! 1 0 ! 0 1 Os operadores lógicos são comumente utilizados em conjunto com outros operadores, por exemplo:\nint x = 1, y = 2, z = 3, w; w = (x \u0026lt; y) \u0026amp;\u0026amp; (x \u0026lt; z); // w recebe o valor 1, como resultado de (1) \u0026amp;\u0026amp; (1) w = (x == y) \u0026amp;\u0026amp; (x \u0026lt; z); // w recebe o valor 0, como resultado de (0) \u0026amp;\u0026amp; (1) w = (x \u0026gt;= y) || (x \u0026lt; z); // w recebe o valor 1, como resultado de (0) || (1) w = (x == y) || (x == z); // w recebe o valor 0, como resultado de (0) || (0) w = !(x == y); // w recebe o valor 1, como resultado de !(0) Comandos condicionais # Podemos adicionar avaliação de condições no código para decidir se um conjunto de instruções deverá ser executado. Condições são expressões cujo resultado será verdadeiro ou falso. Uma vez verdadeiro, o código associado à estrutura condicional será executado. A linguagem C possui três formas de estruturas condicionais:\nif-else switch-case E a estrutura condição ? verdadeiro : falso. IF-ELSE # Vamos começar entendo a estrutura de código condicional utilizando apenas o comando IF. A sintaxe do comando é: (Leia-se: SE condição for verdadeira, ENTÃO a instrução seguinte será executada. )\nif (condição) instrução; Por exemplo, considere uma variável x, cujo valor será inserido pelo usuário: (Leia-se: SE x for maior que zero, ENTÃO imprima na tela o texto \u0026ldquo;O valor de x é positivo\u0026rdquo;. )\nif (x \u0026gt; 0) printf(\u0026#34;O valor de x é positivo.\u0026#34;); A sintaxe acima funciona apenas para avaliação condicional de uma única linha de instrução. Para incluir mais linhas de instrução, devemos adicionar um par de chaves {} para iniciar e fechar um bloco de instruções. Dessa forma, todas as instruções dentro do bloco serão executadas apenas se a condição for verdadeira.\nif (condição){ // inicio do bloco de instruções; instrução_01; instrução_02; ... instrução_N; } // final do bloco de instruções; Exemplo:\nif (x \u0026gt; 0){ printf(\u0026#34;O valor de x é positivo.\u0026#34;); x = x + 1; z = x; } Podemos também escrever instruções que deverão ser executadas caso a condição seja falsa. Para isso, complementamos a estrutura do IF com o ELSE. A sintaxe é: (Leia-se: SE condição for verdadeira, ENTÃO instrução_se_condição_verdadeira será executada, SE NÃO, instrução_se_condição_falsa será executada. )\nif (condição) instrução_se_condição_verdadeira; else instrução_se_condição_falsa; Por exemplo: (Leia-se: SE x for maior que zero, ENTÃO imprima na tela o texto \u0026ldquo;O valor de x é positivo\u0026rdquo;, SE NÃO, imprima na tela o texto \u0026ldquo;O valor de x é negativo ou igual a zero\u0026rdquo;. )\nif (x \u0026gt; 0) printf(\u0026#34;O valor de x é positivo.\u0026#34;); else printf(\u0026#34;O valor de x é negativo ou igual a zero.\u0026#34;); Da mesma forma, podemos criar blocos de instruções a partir do else. Por exemplo:\nif (x \u0026gt; 0){ printf(\u0026#34;O valor de x é positivo.\u0026#34;); x = x + 1; z = x; } else { printf(\u0026#34;O valor de x é negativo ou igual a zero.\u0026#34;); w = x; } É possível fazer o aninhamento da estrutura IF-ELSE.\nif (condição_01){ instrução_01; } else if (condição_02){ instrução_02; } else { instrução_03; } Exemplo:\nif (x \u0026gt; 0) { printf(\u0026#34;O valor de x é positivo.\u0026#34;); } else if (x \u0026lt; 0) { printf(\u0026#34;O valor de x é negativo.\u0026#34;); } else{ printf(\u0026#34;O valor de x é zero.\u0026#34;); } Podemos fazer quantos aninhamentos quisermos, por exemplo:\nint lados = 0; printf(\u0026#34;Digite o número de lados do seu polígono:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. if (lados == 3) { printf(\u0026#34;O polígono é um triângulo.\u0026#34;); } else if (lados == 4) { printf(\u0026#34;O polígono é um quadrilátero.\u0026#34;); } else if (lados == 5) { printf(\u0026#34;O polígono é um pentágono.\u0026#34;); } else if (lados == 6) { printf(\u0026#34;O polígono é um hexágono.\u0026#34;); } else if (lados == 7) { printf(\u0026#34;O polígono é um heptágono.\u0026#34;); } else{ printf(\u0026#34;Valor não identificado.\u0026#34;); } Como temos uma única linha de instrução para cada condição, poderíamos reescrever o código acima dessa forma:\nif (lados == 3) printf(\u0026#34;O polígono é um triângulo.\u0026#34;); else if (lados == 4) printf(\u0026#34;O polígono é um quadrilátero.\u0026#34;); else if (lados == 5) printf(\u0026#34;O polígono é um pentágono.\u0026#34;); else if (lados == 6) printf(\u0026#34;O polígono é um hexágono.\u0026#34;); else if (lados == 7) printf(\u0026#34;O polígono é um heptágono.\u0026#34;); else printf(\u0026#34;Valor não identificado.\u0026#34;); SWITCH-CASE # Blocos de códigos condicionais também podem ser criados com a estrutura SWITCH-CASE. A sintaxe é:\nswitch(variável){ case valor_1: instruções; //podem ser várias linhas de instruções break; case valor_2: instruções; break; ... case valor_m: instruções; break; default: instruções; } Vamos entender:\nA variável dentro do switch() poderá ser do tipo int ou char; O switch é composto por blocos case. Cada bloco case é um teste para saber se o valor da variável é igual ao valor declarado após o nome case (valor_1, no exemplo do primeiro bloco case). Caso seja igual, as instruções pertencentes ao bloco serão executadas. Caso seja diferente, o próximo bloco case será testado. Podemos ler a estrutura acima dessa forma: \u0026ldquo;Caso o valor de variável seja igual a valor_1, execute as instruções do primeiro bloco case, pule todas as outras, e finalize a execução do switch. Caso seja diferente: Execute o mesmo teste para os blocos case sequintes com seus respectivos valores. O último bloco é o default. Se o valor de variável for diferente de todos os valores declarados nos blocos case, as instruções do bloco default serão executadas. Esse bloco é opcional. Perceba que o último comando de cada bloco case é o break. Este comando é o responsável pelo comportamento de \u0026ldquo;pular todos os outros\u0026rdquo; blocos case após encontrar o valor correspondente em um bloco corrente. Vejamos um código exemplo de SWITCH-CASE:\nint lados = 0; printf(\u0026#34;Digite o número de lados do seu polígono:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. switch(lados){ case 3: printf(\u0026#34;O polígono é um triângulo.\u0026#34;); break; case 4: printf(\u0026#34;O polígono é um quadrilátero.\u0026#34;); break; case 5: printf(\u0026#34;O polígono é um pentágono.\u0026#34;); break; case 6: printf(\u0026#34;O polígono é um hexágono.\u0026#34;); break; case 7: printf(\u0026#34;O polígono é um heptágono.\u0026#34;); break; default: printf(\u0026#34;Valor não identificado.\u0026#34;); } Caso o usuário digite 3, o programa imprimirá na tela apenas O polígono é um triângulo.. Se o usuário digitar um valor que não está declarado em nenhum bloco case, por exemplo, 10, o programa imprimirá: Valor não identificado.\nO comando break é opcional, porém, o SWITCH-CASE funciona de forma diferente se não o utilizarmos. Após encontrar o valor correspondente em um bloco case, todos os outros blocos sequintes serão executados também. Por exemplo, considere o mesmo código sem os comandos break:\nint lados = 0; printf(\u0026#34;Digite o número de lados do seu polígono:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;lados); // O usuário informará algum valor, não sabemos qual será. switch(lados){ case 3: printf(\u0026#34;O polígono é um triângulo.\u0026#34;); case 4: printf(\u0026#34;O polígono é um quadrilátero.\u0026#34;); case 5: printf(\u0026#34;O polígono é um pentágono.\u0026#34;); case 6: printf(\u0026#34;O polígono é um hexágono.\u0026#34;); case 7: printf(\u0026#34;O polígono é um heptágono.\u0026#34;); default: printf(\u0026#34;Valor não identificado.\u0026#34;); } Neste caso, se o usuário digitar 3, o programa imprimirá na tela: O polígono é um triângulo. O polígono é um quadrilátero. O polígono é um pentágono. O polígono é um hexágono. O polígono é um heptágono. Valor não identificado..\nDa mesma forma, se o usuário digitar 5, o programa imprimirá: O polígono é um pentágono. O polígono é um hexágono. O polígono é um heptágono. Valor não identificado.\nCondição ? verdadeiro : falso # (em breve)\nComandos de repetição # As estruturas condicionais estudadas acima executam um bloco de intruções quando uma determinada condição é satisfeita. O bloco é executado apenas uma vez, e o programa prossegue executando as próximas instruções de código, caso existam. As vezes, alguns algorítmos requerem a repetição da execução do mesmo bloco de instruções enquanto uma condição continua sendo satisfeita. Para isso, utilizamos comandos de repetição. A linguagem C possui três formas de estruturas de repetição:\nfor while do while FOR # O comando for permite a repetição de um bloco de instruções enquanto uma condição for satisfeita. A sintaxe do comando for é:\nfor (variável_de_inicialização; condição; incremento){ instruções; } Vamos entender:\nvariável_de_inicialização normalmente contém a declaração e/ou a atribuição de um valor à uma variável que será utilizada como um contador de repetições. condição normalmente contém uma expressão boleana envolvendo a variável_de_inicialização. incremento normalmente contém a adição ou subtração da variável_de_inicialização. O comando for funciona da seguinte forma:\nPrimeiro a instrução em variável_de_inicalização é executada; Em seguida, a condição é testada. Se o resultado for verdadeiro, o bloco de instruções é executado. Ao final da execução do bloco, o comando em incremento é executado. Então, a condição é testada novamente, e o bloco de instruções será executado novamente caso o resultado seja verdadeiro. Executa-se o comando em incremento novamente, e a repetição entre testar condição -\u0026gt; executar bloco de instruções -\u0026gt; executar incremento continua até que a condição não seja satisfeita, ou seja, retorne falso. Um exemplo de código:\nfor (int i = 1; i \u0026lt; 5; i++){ printf(\u0026#34;Repetição %d. \u0026#34;, i); } A saída do código será:\nRepetição 1. Repetição 2. Repetição 3. Repetição 4. Outro exemplo:\nfor (int i = 4; i \u0026gt; 0; i--){ printf(\u0026#34;Repetição %d. \u0026#34;, i); } A saída do código será:\nRepetição 4. Repetição 3. Repetição 2. Repetição 1. Existem variações na estrutura do comando for, mas não trabalharemos com as variações neste momento.\nWHILE # Outra estrutura de repetição é a do comando WHILE. A sintaxe é: (Leia-se: Enquanto condição for verdadeira, execute o bloco de instruções.)\nwhile (condição) { instruções; } Com uma sintaxe mais simples, o while define a condição para que uma sequência de instruções seja executada. O comando testa a condição repetidamente após finalizar a execução de todas as instruções definidas em seu bloco (entre { }). No momento em que a condição não for mais satisfeita, o bloco de instrucões não será mais executado, e a próxima instrução no código será executada, caso exista.\nPodemos conseguir o mesmo efeito do código com a estrutura for anterior, por exemplo:\nint i = 1; while(i \u0026lt; 5) { printf(\u0026#34;Repetição %d. \u0026#34;, i); i++; } A saída do código será:\nRepetição 1. Repetição 2. Repetição 3. Repetição 4. DO WHILE # Uma estrutura semelhante à do WHILE é a DO WHILE. A sintaxe é: (Leia-se: Faça a execução do bloco de instruções, enquanto condição for verdadeira.)\ndo { instruções } while(condição) A diferença desse comando para o while anterior é que o bloco de instruções é executado a primeira vez sem que a condição seja testada. Ao final da primeira execução a condição é avaliada, e se verdadeira, o compilador retorna para o início do bloco novamente, e o mesmo ciclo de repetições acontece até que a condição não seja mais satisfeita.\nExemplo de código:\nint i = 1; do { printf(\u0026#34;Repetição %d. \u0026#34;, i); i++; } while(i \u0026lt; 5) A saída do código também será:\nRepetição 1. Repetição 2. Repetição 3. Repetição 4. Comando break # Vimos anteriormente a utilização do comando break em conjunto com o SWITCH-CASE. Porém, o comando break também pode ser utilizado dentro de blocos de intruções de estruturas de repetição. Neste caso, o comando interrompe toda a execução do laço de petição, finalizando a execução da estrutura de repetição ao qual se encontra. Por exemplo:\nint i = 1, j = 0; printf(\u0026#34;Digite um número de 1 a 4: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); while(i \u0026lt; 5) { if(i == j){ break; } printf(\u0026#34;Repetição %d. \u0026#34;, i); i++; } No código acima, incluímos uma variável j cujo valor será inserido pelo usuário na execução do programa. Incluímos, também, uma condição if dentro do while, que compara o valor da variável i com j. Caso sejam iguais, o comando break é executado, e todo o comando while será finalizado (isso inclui todas as instruções após o bloco do if).\nCaso o usuário digite 3, a saída será:\nRepetição 1. Repetição 2. Comando continue # Assim como o comando break, o comando continue pode ser utilizado dentro de blocos de instruções de estruturas de repetição. Porém, ao invés de finalizar toda a execução da estrutura de repetição, o continue finaliza apenas a execução da repetição corrente, e a próxima repetição poderá ser executada (caso a condição continue sendo verdadeira). Por exemplo:\nint i = 1, j = 0; printf(\u0026#34;Digite um número de 1 a 4: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); while(i \u0026lt; 5) { if(i == j){ i++; continue; } printf(\u0026#34;Repetição %d. \u0026#34;, i); i++; } Neste caso, se o usuário digitar 3, a saída será:\nRepetição 1. Repetição 2. Repetição 4. Observe que, na repetição à qual i assumiu o valor 3, a condição i == j passou a ser verdadeira, e o comando continue foi executado. Sendo assim, as instruções seguintes dentro do bloco while foram puladas, e a condição do while voltou a ser testada para uma nova repetição do seu bloco de instruções. Observe também que incluí o incremento da variável i dentro do bloco if. Consegue me explicar o porquê? Me conte na próxima aula!\nArrays # Até agora trabalhamos com variáveis que comportavam um único valor, por exemplo, um número ou um caractere. A linguagem também permite criarmos variáveis que comportem um conjunto de valores, como uma lista de valores. Começaremos entendendo o que são arrays.\nArrays são variáveis que representam uma lista de valores do mesmo tipo, e podemos acessar cada valor da lista indexando a variável com as posições dos elementos na lista. A sintaxe da declaração é:\ntipo nome_da_variavel[tamanho_da_lista]; Por exemplo:\nint numeros[5]; //uma variável que comporta 5 números inteiros diferentes. Conseguimos atribuir valores ou acessar cada um dos 5 números da variável numeros através de índices ordenados. Indices em arrays são números inteiros positivos, e começam do valor zero. Na declaração da variável numeros, temos 5 posições de memória que podem ser acessadas com os índices 0, 1, 2, 3 e 4. Vejamos no código:\nint numeros[5]; numeros[0] = 10; numeros[1] = 11; numeros[2] = 12; numeros[3] = 13; numeros[4] = 14; for(int i = 0; i \u0026lt; 5; i++){ printf(\u0026#34;%d \u0026#34;, numeros[i]); } No código acima, estamos primeiro atribuindo valores à cada uma das posições da variável numeros. Em seguida, estamos percorrendo toda a variável com a estrutura de repetição for para imprimir os valores de cada posição na tela. Note que, não existe a posição numeros[5], esta representaria um sexto elemento e extrapolaria o tamanho declarado da variável. A saída do programa será:\n10 11 12 13 14 Da mesma forma que fizemos com as variáveis \u0026ldquo;simples\u0026rdquo;, também podemos inicializar um array em sua declaração. Exemplo:\nint numeros[5] = {10, 11, 12, 13, 14}; for(int i = 0; i \u0026lt; 5; i++){ printf(\u0026#34;%d \u0026#34;, numeros[i]); } Atribuição # A linguagem C não permite a atribuição de arrays. Ou seja, não é possível copiar o valor de um array para outro com uma simples atribuição de variáveis. Para copiar, precisamos percorrer todo o array. Exemplo:\nint numeros_1[5] = {10, 11, 12, 13, 14}; int numeros_2[5]; //Copiar os valores de numeros_1 para numeros_2 for(int i = 0; i \u0026lt; 5; i++){ numeros_2[i] = numeros_1[i]; } //Imprimir os valores de numeros_2 for(int i = 0; i \u0026lt; 5; i++){ printf(\u0026#34;%d \u0026#34;, numeros_2[i]); } Matrizes # Arrays possuem uma única dimensão.\nEventualmente, precisamos organizar várias listas de valores associados. Para isso, podemos utilizar matrizes.\nMatrizes são arrays que podem ter várias dimensões!\nNeste curso, estudaremos as matrizes com duas dimensões. Assim como na matemática, podemos chamar a primeira dimensão de linha e a segunda de coluna. A sintaxe da declaração é:\ntipo nome_da_variável[numero_de_linhas][numero_de_colunas]; Exemplo de código:\n// Declaração de uma matriz com duas linhas linhas e três colunas int numeros[2][3]; //uma variável que comporta 6 elementos numeros[0][0] = 10; numeros[0][1] = 11; numeros[0][2] = 12; numeros[1][0] = 13; numeros[1][1] = 14; numeros[1][2] = 15; for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026#34;%d \u0026#34;, numeros[i][j]); } printf(\u0026#34;\\n\u0026#34;); } Perceba que agora precisamos usar indexadores diferentes para cada dimensão, um para acessar a posição da linha e outro para a coluna. O par de indexadores representa o acesso a um único elemento na matriz. Por exemplo, numeros[0][0] acessa o primeiro elemento da matriz, que está na linha zero e coluna zero. Da mesma forma, para percorrer a matriz e imprimir seus elementos precisamos de duas estruturas de repetição, uma para cada dimensão. Cada estrutura define um indexador diferente. No código de exemplo, utilizamos os inteiros i e j para indexar linhas e colunas, respectivamente. Perceba que acrescentei um printf(\u0026quot;\\n\u0026rdquo;) após a finalização do for que percorre as colunas. Dessa forma, após a impressão de cada coluna completa, pularemos uma linha para iniciar a impressão da próxima coluna. A saída do programa será:\n10 11 12 13 14 15 Uma matriz também pode ser inicializada em sua declaração, como fizemos com arrays. A linguagem C permite duas sintaxes diferentes, vejamos o exemplo:\n//Inicalização com todos os elementos em sequência. int numeros_1[2][3] = {10, 11, 12, 13, 14, 15}; //Inicialização com um par de {} interno para cada coluna da matriz int numeros_2[2][3] = {{10, 11, 12}, {13, 14, 15}}; printf(\u0026#34;A matriz numeros_1 é: \\n\u0026#34;); for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026#34;%d \u0026#34;, numeros_1[i][j]); } printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;\\nA matriz numeros_2 é: \\n\u0026#34;); for(int i = 0; i \u0026lt; 2; i++){ for(int j = 0; j \u0026lt; 3; j++){ printf(\u0026#34;%d \u0026#34;, numeros_2[i][j]); } printf(\u0026#34;\\n\u0026#34;); } No exemplo, numeros_1 e numeros_2 são duas matrizes diferentes. Utilizamos uma sintaxe de inicalização diferente para elas, mas as duas foram inicializadas com os mesmos valores. Dessa forma, na impressão da tela as duas matrizes serão iguais.\nStrings # Strings são sequências de caracteres. Em C, uma sequência de caracteres nada mais é do que um array do tipo char. Podemos criar arrays de char da mesma forma que fizemos com os outros tipos anteriormente. Além disso, aos arrays de char também podem ser atribuídos textos diretamente. Vejamos exemplos de declaração de strings:\n// Inicialização com caracteres char string_1[7] = {\u0026#39;S\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;\\0\u0026#39;}; // Inicialização com texto char string_2[7] = \u0026#34;String\u0026#34;; char string_3[7]; string_3 = \u0026#34;String\u0026#34; printf(\u0026#34;%s\u0026#34;, string_1); printf(\u0026#34;%s\u0026#34;, string_2); printf(\u0026#34;%s\u0026#34;, string_3); Os strings em C possuem um \\0 ao final para representar o final do string. Observe que na declaração de string_1 adicionamos explicitamente o \\0. Na inicialização com texto, isso já é feito pelo compilador de forma implícita. Observe, também, que devemos contabilizar esse último caractere na definição do tamanho do array.\nOutra novidade é o indicador do tipo de variável no printf, que passou a ser %s.\nLeitura de strings # Podemos utilizar o comando scanf para a leitura de strings, com a seguinte sintaxe:\nchar nome[20]; printf(\u0026#34;Digite um nome:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, nome); printf(\u0026#34;%s \u0026#34;, nome); Observe que utilizamos o %s no scanf e não adicionamos o símbolo \u0026amp; à variável associada, como fizemos na leitura de variáveis nos exemplos vistos anteriormente.\nImportante: A leitura de strings com o scanf é interrompida ao ser encontrado o primeiro espaço em branco digitado. Dessa forma, se o usuário digitar, por exemplo, Ana Maria, no nosso exemplo, apenas o Ana será atribuído à variável nome.\nAlternativamente, podemos utilizar a função gets(). Esta támbém é uma função presente na biblioteca padrão da linguagem C, e é possível ler frases inteiras com espaços em brancos. A leitura é finalizada ao ser encontrado o caractere que representa uma quebra de linha (\\n), ou seja, quando o usuário digitar enter. Vejamos exemplo:\nchar frase[20]; printf(\u0026#34;Digite uma frase:\u0026#34;); gets(frase); printf(\u0026#34;%s \u0026#34;, frase); Troubleshooting: Já presenciei alguns erros reportados pelos alunos nas aulas de laboratório, utilizando essas funções de leitura de strings. Um erro comum era o retorno de caracteres errados. Uma possível solução é realizar a limpeza da memória buffer do teclado antes de realizar a leitura. Para isso, utilizamos a função setbuf com a configuração setbuf(stdin, NULL). Exemplo:\nchar frase[20]; // Limpeza do buffer - Atribui o valor NULL à setbuf(stdin, NULL); printf(\u0026#34;Digite uma frase:\u0026#34;); gets(frase); printf(\u0026#34;%s \u0026#34;, frase); O nome stdin representa o buffer de entrada padrão do sistema, e o exemplo atribui o valor NULL a ele.\nBiblioteca \u0026lt;string.h\u0026gt; # A biblioteca padrão da linguagem C possui um conjunto de funções para manipulação de strings. Para utilizá-las, é necessário adicionar a biblioteca string.h no cabeçalho do programa:\n#include \u0026lt;string.h\u0026gt; Vejamos exemplos de funções:\nComprimento do string # A função strlen() recebe um string como parâmetro de entrada e retorna o número de caracteres não nulos do string:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char palavra[20] = \u0026#34;livro\u0026#34;; int tamanho = strlen(palavra); printf(\u0026#34;A palavra tem %d letras.\u0026#34;, tamanho); } A saída do código acima será o número de caracteres da palavra livro:\nA palavra tem 5 letras. Comparação de strings # A função strcmp() recebe dois strings como parâmetros de entrada e retorna:\n0 quando os strings são exatamente iguais. um valor diferente de 0 quando os strings são diferentes. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char palavra_1[20] = \u0026#34;livro\u0026#34;; char palavra_2[20] = \u0026#34;LIVRO\u0026#34;; int resultado_1 = strcmp(palavra_1, \u0026#34;livro\u0026#34;); //retornará zero int resultado_2 = strcmp(palavra_1, palavra_2); //retornará valor diferente de zero printf(\u0026#34;Comparação 01: %d\u0026#34;, resultado_1); printf(\u0026#34;\\n Comparação 02: %d\u0026#34;, resultado_2); } Um exemplo de saída é:\nComparação 01: 0 Comparação 02: 32 Concatenação de string # A função strcat() recebe dois strings como parâmetros de entrada e concatena o segundo string ao primeiro. Dessa forma, apenas o primeiro string é alterado. O caractere de finalização (\\n) do primeiro string é substituído pelo primeiro caractere do segundo string.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char palavra_1[20] = \u0026#34;Bons \u0026#34;; char palavra_2[20] = \u0026#34;estudos!\u0026#34;; strcat(palavra_1, palavra_2); //retornará zero printf(\u0026#34;palavra_1: %s\u0026#34;, palavra_1); } A saída será:\nBons estudos! Ponteiros # Já sabemos que as variáveis que criamos em nossos programas são armazenadas na memória do computador. Vamos entender melhor essa estrutura.\nCada posição de memória possui um endereço associado. Dessa forma, toda a estrutura de memória é organizada como pares: o endereço e o espaço reservado para armazenar algum conteúdo.\nQuando declaramos uma variável e atribuímos a ela algum valor, essa variável é associada a algum endereço de memória, e o valor que atribuímos a ela é armazenado na posição de conteúdo correspondente ao endereço alocado. A tabela abaixo traz uma ilustração (fictícia) desse conceito:\nVariável Endereço Conteúdo \u0026hellip; int x; 1000 00101011 1001 10101011 1002 01001000 1004 01001010 int z; 1005 10101001 \u0026hellip; Podemos acessar o endereço de memória associado à uma variável utilizando o operador de endereçamento \u0026amp; antes do nome da variável. Por exemplo:\n#include \u0026lt;stdio.h\u0026gt; int main(){ int varInt; printf(\u0026#34;Endereço de memória de varInt: %p\u0026#34;, \u0026amp;varInt); return 0; } Um exemplo de saída é:\nEndereço de memória de varInt: 0x7ff7bdc9f3c8 Endereços de memória podem ser visualizados como decimais ou hexadecimais. Utilizamos a sequência de caracteres %p para representar o endereço em hexadecimal.\nPonteiros são formas especiais de variáveis que armazenam endereços de memória. A sintaxe de declaração de um ponteiro é:\ntipo *nome_da_variavel; Por exemplo:\nint *pointInt; // um ponteiro que pode \u0026#34;apontar\u0026#34; para uma variável do tipo int float *pointFloat; // um ponteiro que pode \u0026#34;apontar\u0026#34; para uma variável do tipo float Acrescentamos à declaração da variável o símbolo * para informar que a variável é um ponteiro. Ao armazenar um endereço de memória de alguma variável X, dizemos que o ponteiro \u0026ldquo;aponta\u0026rdquo; para essa variável X. Vejamos um exemplo:\n#include \u0026lt;stdio.h\u0026gt; int main(){ int varInt = 10; int *pointInt; // declaração do ponteiro pointInt = \u0026amp;varInt; // inicialização do ponteiro printf(\u0026#34;varInt: %d\u0026#34;, varInt); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;pointInt: %d\u0026#34;, *pointInt); //acesso ao valor \u0026#34;apontado\u0026#34; return 0; } A saída do programa é:\nvarInt: 10 pointInt: 10 Vamos entender:\nvarInt é uma variável do tipo inteiro, inicalizada com o conteúdo 10. pointInt é um ponteiro que poderá apontar para uma variável do tipo inteiro. O comando pointInt = \u0026amp;varInt atribui o endereço de varInt à variável pointInt. Lembre-se, ponteiros armazenam endereços de memória. Ou seja, pointInt está \u0026ldquo;apontando\u0026rdquo; para varInt. Sendo assim, podemos acessar o valor de varInt através do seu ponteiro pointInt. A sintaxe para acesso é: *pointInt. Em resumo,\npointInt armazena um endereço de memória, e *pointInt acessa o conteúdo que está armazenado nesse endereço. Vejamos um código mais detalhado:\n#include \u0026lt;stdio.h\u0026gt; int main(){ int varInt = 10; int *pointInt = NULL; //ponteiro inicializado com valor nulo. printf(\u0026#34;Variável varInt:\u0026#34;); printf(\u0026#34;\\n - Endereço de memoria: (em hexadecimal) %p (em decimal) %d\u0026#34;, \u0026amp;varInt, \u0026amp;varInt); printf(\u0026#34;\\n - Valor armazenado: %d\\n\\n\u0026#34;, varInt); pointInt = \u0026amp;varInt; // o endereço de memória de varInt será o conteúdo de pointInt. printf(\u0026#34;Variável pointInt:\u0026#34;); printf(\u0026#34;\\n - Endereço de memoria: (em hexadecimal) %p (em decimal) %d\u0026#34;, \u0026amp;pointInt, \u0026amp;pointInt); printf(\u0026#34;\\n - Valor armazenado: (em hexadecimal) %p (em decimal) %d\u0026#34;, pointInt, pointInt); printf(\u0026#34;\\n - Conteudo da posicao apontada: %d \\n\u0026#34;, *pointInt); return 0; } Um exemplo de saída é:\nVariável varInt: - Endereço de memoria: (em hexadecimal) 0x7ff7bf0a93c8 (em decimal) -1089825848 - Valor armazenado: 10 Variável pointInt: - Endereço de memoria: (em hexadecimal) 0x7ff7bf0a93c0 (em decimal) -1089825856 - Valor armazenado: (em hexadecimal) 0x7ff7bf0a93c8 (em decimal) -1089825848 - Conteudo da posicao apontada: 10 Aritmética de ponteiros # A aritmética de ponteiros refere-se às operações matemáticas que você pode realizar com ponteiros. Essas operações são baseadas no tipo de dado para o qual o ponteiro está apontando. A linguagem C permite adição e subtração entre ponteiros e inteiros, e permite a subtração entre ponteiros entre si.\nPor exemplo, se você tem um ponteiro p e o incrementa com 3 (p + 3), você obterá o avanço de três blocos de memória do tipo ao qual o ponteiro está apontando. Vejamos.\nConsidere o ponteiro p:\nint *p; A expressão de adição\np + 3 é válida. Signica que você terá acesso ao endereço da posição de memória que está três objetos adiante do endereço do objeto para o qual p aponta. Como p é um endereço, p + 3 também resultará em um endereço. O compilador ajustará o endereço de acordo com o tamanho do tipo. Isso é feito multiplicando o valor a ser adicionado pelo tamanho do tipo de dado para o qual p aponta.\nPor exemplo, se o endereço atual contido em p é 1000, e considerando que o tipo int ocupa 4 bytes, então, p + 3 significa 1000 + 3*4, que é igual ao endereço 1012.\nPor outro lado, se p fosse um ponteiro para char, com a declaração *char p, então p + 3 significaria 1003.\nPortanto, p + 3 sempre significa o endereço do terceiro objeto após p, independentemente do tipo de objeto para o qual p aponta.\nSeguem exemplos de expressões legais e ilegais utilizando aritmética de ponteiros:\nint *p1, *p2; char * p3; long j; //EXPRESSÕES VÁLIDAS p1++; // Avança para o próximo elemento int p2--; // Retrocede um elemento int p3 = p3 + 5; // Avança 5 bytes a partir do endereço de p3 p1 = p1 - 2; // Retrocede 2 elementos int p1 = p1 + 3; // Avança 3 elementos int (supondo que p1 é para int) j = p2 - p1; // Calcula o número de elementos int entre p1 e p2 //EXPRESSÕES ILEGAIS p3 = p1 + 2; // Ilegal: ponteiros para tipos diferentes p1 = p3 - 1; // Ilegal: ponteiros para tipos diferentes j = p3 - p2; // Ilegal: ponteiros para tipos diferentes p1 = p1 + p2; // Ilegal: não é permitido adicionar dois ponteiros p3 = p1 - p2; // Ilegal: resultado da subtração de ponteiros não pode ser usado como um ponteiro Aritmética de ponteiros é especialmente útil quando você está trabalhando com arrays, pois um array é basicamente um bloco contíguo de memória que armazena uma sequência de elementos do mesmo tipo. A seguir, veremos a relação entre ponteiros e arrays, e como podemos utilizar aritmética de ponteiros para manipulação de arrays.\nRelação entre ponteiros e arrays # Em C, arrays e ponteiros estão intimamente relacionados. Quando você usa o nome de um array em uma expressão, ele é convertido para um ponteiro para o seu primeiro elemento.\nPor exemplo, considere o seguinte array:\nint numeros[5] = {1, 2, 3, 4, 5}; Aqui, numeros é o nome do array, mas em muitas expressões, é tratado como um ponteiro para o primeiro elemento do array.\nIsso significa que numeros é equivalente a \u0026amp;numeros[0]. Portanto, se você fizer:\nint numeros[5] = {1, 2, 3, 4, 5}; int *p = numeros; // p aponta para arr[0] printf(\u0026#34;%d \u0026#34;, *p); //imprime o conteúdo de numero[0] printf(\u0026#34;\\n%d \u0026#34;, numeros[0]); //também, imprime o mesmo conteúdo A saída do código será:\n1 1 No exemplo acima, p é um ponteiro que aponta para o primeiro elemento de numeros. Você pode acessar os elementos do array usando esse ponteiro da mesma forma que acessaria os elementos do array diretamente, utilizando aritmética de ponteiros. Exemplo:\nint numeros[5] = {1, 2, 3, 4, 5}; int *p = numeros; // p aponta para arr[0] printf(\u0026#34;%d\\n\u0026#34;, *(p + 2)); // Imprime o terceiro elemento do array, que é 3 A saída do código será:\n3 Segue outro exemplo de manipulação de array utilizando ponteiros:\n#include \u0026lt;stdio.h\u0026gt; int main() { int array[5] = {10, 20, 30, 40, 50}; // Declaração e inicialização do array int *ptr = array; // Ponteiro que aponta para o início do array // Acesso e impressão dos elementos usando aritmética de ponteiro for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;Elemento %d: %d\\n\u0026#34;, i, *(ptr + i)); } return 0; } Funções # Podemos organizar o código em blocos que delimitam um escopo próprio para a realização de uma tarefa específica, e que podem ser reaproveitados em diferentes pontos do código. Fazemos isso através de funções. A sintaxe da declaração de uma função é:\ntipo_de_retorno nome_da_função(tipo_de_parametro_de_entrada nome_parametro_de_entrada){ instruções; return valor_de_retorno; } Vamos entender\nUma função pode receber parâmetros de entrada para utilizar os valores dos parâmetros na realização de alguma tarefa. Para especificar um parâmetro de entrada da função, devemos declarar o seu tipo em tipo_de_parametro_de_entrada seguido do nome que utilizaremos para acessar o parâmetro dentro da função, declarado em nome_parametro_de_entrada.\nParâmetros de entrada são opcionais. Podemos ter vários parâmetros de entrada separados por vírgula, cada um com sua declaração completa (tipo e nome). Uma função pode retornar algum valor, e definimos o tipo do valor na sua declaração em tipo_de_retorno. Neste caso, após realizar sua atividade, a função deverá retornar um valor do tipo declado utilizando a palavra reservada return.\nCaso a função não precise retornar valor algum, utilizamos a palavra void na declaração, e o return será desnecessário. Podemos utilizar return em qualquer ponto do corpo da função. Acessaremos a função através do seu nome, declarado em nome_da_função.\nVejamos exemplos:\n#include \u0026lt;stdio.h\u0026gt; // Função sem parâmetros de entrada e sem retorno. void funcao_1(){ printf(\u0026#34;Execução da função 1.\\n\u0026#34;); } // Função com dois parâmetros de entrada, e que retorna um número inteiro. int funcao_2(int a, int b){ printf(\u0026#34;\\nExecução da função 2, com os valores de entrada %d e %d.\\n\u0026#34;, a, b); return a+b; } int main(){ printf(\u0026#34;Iniciando a execução do programa.\\n\u0026#34;); funcao_1(); //Instanciando funcao_1 int valor = funcao_2(1, 2); //Instanciando funcao_2 printf(\u0026#34;A soma de 1 e 2 é %d\u0026#34;, valor); //Instanciando funcao_2 novamente printf(\u0026#34;A soma de 10 e 11 é %d\u0026#34;, funcao_2(10, 11)); return 0; } Vamos entender:\nO código começa a ser executado no escopo principal main(), e toda vez que há a chamada de uma função, o fluxo de execução \u0026ldquo;pula\u0026rdquo; para o escopo da função e executa todo o código da função. Ao finalizar a execução da função, o fluxo de execução do programa retorna para o escopo main() e a próxima linha de código após a chamada da função é executada.\nAs funções são declaradas antes de serem chamadas. Perceba que elas foram declaradas antes do inicio do escopo main().\nfuncao_1() é a forma que chamamos funcao_1 para ser executada.\nA funcao_2 possui dois parâmetros de entrada, dessa forma precisamos passar valores de tipos equivalentes na sua chamada. Na chamada funcao_2(1, 2) passamos os valores 1 e 2, que serão atribuídos aos parâmetros a e b da função.\nNas chamadas de funcao_2 do código acima, passamos valores diretamente para serem atribuídos aos parâmetros de entrada da função. Poderíamos, também, passar variáveis como parâmetros. Neste caso, os valores atribuídos previamente às variáveis serão copiados para os parâmetros de entrada da função. Em C, chamamos esse comportamento de passagem de parâmetro por valor. Vejamos um exemplo:\n#include \u0026lt;stdio.h\u0026gt; // Função com um parâmetro de entrada, e que retorna um número fracionado. float funcao_3(int num){ float resultado; if(num == 0){ return 0; } resultado = 10 / num; return resultado; } int main(){ int numero = 10; float resultado = funcao_3(numero); printf(\u0026#34;A função 3 teve como retorno o valor: %f\u0026#34;, resultado ); } No exemplo, a variável numero foi inicalizada com o valor 10, e passamos a variável como parâmetro da chamada de funcao_3. Isso quer dizer que o valor 10 será copiado para o parâmetro de entrada num da função.\nA passagem de parâmetros por valor é o comportamento padrão quando passamos variáveis como parâmetros de entrada de funções. Na passagem por valor, o conteúdo da variável é copiado para a função, e a função não terá acesso à variável.\nExiste outra forma de passar parâmetros para as funções, chamada de passagem por referência.\nQuando desejamos que uma função tenha acesso direto à variável, podendo alterar seu conteúdo, devemos utilizar a passagem de parâmetros por referência. Utilizarmos ponteiros para implementar a passagem por referência.\nA forma de implementar é:\nNa declaração da função, o parâmetro de entrada deverá ser declarado como um ponteiro. Ao operar com a variável dentro da função, devemos lembrar de utilizar o ponteiro para o conteúdo apontado (ex. *pointInt). Na chamada da função, devemos passar o endereço de memória da variável que queremos passar como parâmetro. Vejamos um exemplo:\n#include \u0026lt;stdio.h\u0026gt; // 1. Declaramos os parâmetros de entrada da função como ponteiros void funcao_passagem_referencia(int *a, int *b){ *a += 1; // 2. Utilizamos o ponteiro para o conteúdo apontado *b -= 1; } int main(){ int x = 10, y = 10; printf(\u0026#34;Valores antes da chamada da função: x = %d e y = %d\u0026#34;, x,y); funcao_passagem_referencia(\u0026amp;x, \u0026amp;y); // 3. Passamos os endereços de memória printf(\u0026#34;\\nValores após a chamada da função: x = %d e y = %d\u0026#34;, x,y); return 0; } A saída do programa será:\nValores antes da chamada da função: x = 10 e y = 10 Valores após a chamada da função: x = 11 e y = 9 Os valores de x e y foram modificados. Uma função com passagem de parâmetros por valor não alteraria os valores de x e y. Vejamos um exemplo equivalente:\n#include \u0026lt;stdio.h\u0026gt; void funcao_passagem_valor(int a, int b){ a += 1; b -= 1; } int main(){ int x = 10, y = 10; printf(\u0026#34;Valores antes da chamada da função: x = %d e y = %d\u0026#34;, x,y); funcao_passagem_valor(x, y); printf(\u0026#34;\\nValores após a chamada da função: x = %d e y = %d\u0026#34;, x,y); return 0; } A saída do programa será:\nValores antes da chamada da função: x = 10 e y = 10 Valores após a chamada da função: x = 10 e y = 10 Mais sobre variáveis # Modificadores # Na linguagem C, modificadores de variáveis são palavras reservadas que alteram a forma como as variáveis são armazenadas e tratadas pelo compilador. Eles permitem especificar características adicionais para variáveis. Vamos explorar os principais modificadores de variáveis em C:\nsigned e unsigned # signed: Indica que uma variável pode armazenar valores positivos e negativos. O modificador signed é o padrão para variáveis caso o mofificador não seja espeficicado. Podem ser utilizados para mofificar os tipos int e char.\nunsigned: Indica que uma variável só pode armazenar valores positivos e zero. É frequentemente usado para variáveis que não precisam representar números negativos, como contadores.\nA qualificação de um tipo é feita antepondo-se o qualificador ao nome do tipo. Por exemplo:\nsigned int num_01 = -10; // Permite valores negativos e positivos unsigned int num_02 = 10; // Apenas valores não negativos short e long # short: Utilizado para reduzir o tamanho da variável. Em muitos sistemas, um short é um int de 16 bits.\nlong: Utilizado para aumentar o tamanho da variável. Em muitos sistemas, um long é um int de 32 bits ou 64 bits, dependendo da arquitetura.\nExemplo:\nshort int num_01 = -10; // Tipicamente 16 bits long int num_02 = 10; // Tipicamente 32 bits ou 64 bits A tabela a seguir apresenta intervalos típicos de valores dos tipos atitméticos.\nTipo Tamanho (em bytes) Intervalo de Valores int 4 -2ˆ31 a 2ˆ31 - 1 short int 2 -2ˆ15 a 2ˆ15 - 1 long int 4 -2ˆ31 a 2ˆ31 - 1 unsigned int 4 0 a 2ˆ32 - 1 unsigned short int 2 0 a 2ˆ16 - 1 unsigned long int 4 0 a 2ˆ32 - 1 signed char 1 -2ˆ7 a 2ˆ7 - 1 unsigned char 1 0 a 2ˆ8 - 1 A seguir, mais um exemplo de utilização de modificadores de tipos de variáveis. Observe que, para imprimir a variável unsigned, utilizamos o %u ao invés de %d.\n#include \u0026lt;stdio.h\u0026gt; int main() { unsigned int u = 4294967295; // O maior valor que um unsigned int pode armazenar signed int s = -2147483648; // O menor valor que um signed int pode armazenar short int si = 32767; // O maior valor que um short int pode armazenar printf(\u0026#34;unsigned int: %u\\n\u0026#34;, u); printf(\u0026#34;signed int: %d\\n\u0026#34;, s); printf(\u0026#34;short int: %d\\n\u0026#34;, si); return 0; } long long # O modificador long long em C é utilizado para declarar variáveis inteiras que necessitam de uma maior capacidade de armazenamento em comparação com os tipos de dados inteiros padrão. É uma extensão do tipo long e é garantido que tenha pelo menos 64 bits de largura. Exemplo:\nlong long int bigNumber = 9223372036854775807; // Maior capacidade de armazenamento para valores inteiros long long int bigNumber_2 = 9223372036854775807LL; // Adicionamos um sufixo LL unsigned long long int bigUnsignedNumber = 18446744073709551615ULL; // Valor máximo para unsigned long long printf(\u0026#34;Signed long long: %lld\\n\u0026#34;, bigNumber_2); printf(\u0026#34;Unsigned long long: %llu\\n\u0026#34;, bigUnsignedNumber); No exemplo, adicionamos os sufixos LL e ULL ao valor das variáveis para garantir que o valor literal seja tratado como long long e unsigned long long, respectivamente.\nObserve, também, que utilizamos especificadores de formato apropriados para imprimir as variáveis:\n%lld para signed long long %llu para unsigned long long volative # (em breve)\nEnumerações # Uma enumeração é um tipo de dado definido pelo usuário que consiste em um conjunto de constantes inteiras nomeadas. Elas são úteis para representar um grupo de valores relacionados de forma legível e organizada.\nDefinimos uma enumeração usando a palavra reservada enum, seguida por um nome para a enumeração e uma lista de identificadores (nomes) para os valores possíveis. Vejamos um exemplo:\nenum DiaDaSemana { DOMINGO, // 0 SEGUNDA, // 1 TERCA, // 2 QUARTA, // 3 QUINTA, // 4 SEXTA, // 5 SABADO // 6 }; Neste exemplo, enum DiaDaSemana define uma enumeração chamada DiaDaSemana com sete valores possíveis. Por padrão, o primeiro valor (DOMINGO) é associado ao número 0, o segundo (SEGUNDA) é 1, e assim por diante.\nTambém é possível atribuir valores explícitos para os elementos da enumeração. Por exemplo:\nenum Status { PENDENTE = 1, EM_ANDAMENTO = 2, CONCLUIDO = 3 }; Se o valor de uma dada constante na enumeração não for definido explicitamente, seu valor será o valor da constante anterior na seqüência acrescido de 1.\nVejamos um exemplo completo de utilização da enumeração:\n#include \u0026lt;stdio.h\u0026gt; enum DiaDaSemana { DOMINGO, SEGUNDA, TERCA, QUARTA, QUINTA, SEXTA, SABADO }; int main() { enum DiaDaSemana hoje = DOMINGO; if (hoje == DOMINGO) { printf(\u0026#34;Hoje é domingo.\\n\u0026#34;); } else { printf(\u0026#34;Hoje não é doming.\\n\u0026#34;); } return 0; } Perceba que a variável hoje é do tipo enum DiaDaSemana e a ela é atribuído o valor DOMINGO. O que aconteceria se atribuíssemos um valor diferente dos valores definidos na enumeração? Faça alterações no código para testar.\nConstantes # Até agora estudamos variáveis que poderiam ser alteradas em diferentes pontos do código após a sua declaração. A linguagem também permite a definição de valores constantes, isto é, que não podem ser alterados durante a execução do programa. Constantes são úteis para representar dados fixos e imutáveis de maneira eficiente, evitando redundâncias no código.\nConstantes definidas com const # O modificador const pode ser usado para definir variáveis que não podem ser alteradas após sua inicialização. Isso cria uma constante com verificação de tipo pelo compilador:\nconst int max_value = 100; // max_value não pode ser alterado após ser definido const float taxaImposto = 0.15; Segue exemplo de utilização:\n#include \u0026lt;stdio.h\u0026gt; const float taxaDesconto = 0.10; int main() { float precoOriginal = 100.0; float desconto = precoOriginal * taxaDesconto; printf(\u0026#34;Desconto: %.2f\\n\u0026#34;, desconto); // Tentativa de modificar a constante // taxaDesconto = 0.15; // Isso causaria um erro de compilação return 0; } Constantes simbólicas com #define # Também é possível definir valores constantes utilizando #define. Essa é uma diretiva de pré-processador que permite definir constantes que são substituídas por valores fixos durante a compilação. Ou seja, quando você usa #define, o pré-processador do compilador substitui todas as ocorrências do identificador pelo valor associado antes da compilação do código. Não é necessário especificar o tipo da constante:\n#define PI 3.14159 #define MAX_VALUE 100 #define ABC \u0026#34;ABCDE!\u0026#34; As regras para nomeação de constantes simbólicas são as mesmas utilizadas para variáveis, mas sugere-se que o programador adote uma notação diferente da utilizada em nomes de variáveis. Por esta razão, os nomes de constantes são normalmente escritos em letras maiúsculas.\nSegue exemplo de utilização:\n#include \u0026lt;stdio.h\u0026gt; // Definições de constantes usando #define #define PI 3.14159 #define RAIO_MAXIMO 10 int main() { // Cálculo da área de um círculo com raio máximo float area = PI * RAIO_MAXIMO * RAIO_MAXIMO; printf(\u0026#34;Área do círculo com raio %d: %.2f\\n\u0026#34;, RAIO_MAXIMO, area); return 0; } Tipos definidos pelo programador # Escopo de variáveis # Mais sobre operadores # Conversões # Operador sizeof # "},{"id":5,"href":"/docs/temp/","title":"temp","section":"Docs","content":""},{"id":6,"href":"/docs/02-py-course/","title":"Sumário de Python","section":"Docs","content":" Sumário de Python # Python é uma linguagem de programação de alto nível, amplamente utilizada devido à sua simplicidade e versatilidade. Sua sintaxe clara e legível a torna ideal para iniciantes.\nApresento aqui um material complementar às aulas ministradas em sala, para revisão da sintaxe da linguagem e auxílio nos estudos.\nWebsite oficial # Para download: https://www.python.org\nCriação de arquivos .py # Executamos código Python em arquivos com extensão .py. Por exemplo: primeiro_programa.py:\nAs regras para nomeação de arquivos são:\nO arquivo deve ter a extensão .py. O nome do arquivo pode conter qualquer caractere alfa-numérico (A-z e 0-9) e o caractere sublinhado (_). Deve começar com uma letra ou o sublinhado. Não podem haver espaços no nome do arquivo. Por exemplo: \u0026ldquo;primeiro programa.py\u0026rdquo;. Sintaxe básica # Primeiro comando em Python # Utilizamos a função print() para imprimir textos na tela:\nprint(\u0026#34;Olá, mundo lindo!\u0026#34;) Comentários # A sintaxe para comentário em Python é:\n# Este é um comentário. # Este é outro comentário. Indentação # Em python, espaços e tabs formando indentações no inicio das linhas de código devem ser utilizadas apenas para aninhar blocos de comando, por exemplo, com os comandos condicionais e de repetição, que veremos adiante. Indentações fora desse contexto representam erro de sintaxe no código.\nPor exemplo, ao executar o código:\nprint(\u0026#34;Instrução 1\u0026#34;) print(\u0026#34;Instrução 2\u0026#34;) printf(\u0026#34;Instrução 3\u0026#34;) Obteremos o seguinte erro:\nIndentationError: unexpected indent Variáveis # Em Python, variáveis são criadas na primeira atribuição de valor, e o valor atribuído definirá o tipo da variável. Por exemplo:\nvarInt = 10 # tipo int - armazena valores inteiros varFloat = 10.5 # tipo float - armazena valores fracionados varStr = \u0026#34;texto\u0026#34; # tipo str - armazena strings varBool = True # tipo bool - armazena os valores boleanos True ou False Podemos ver os tipos das variáveis utilizando o método type(). Se acrescentarmos ao código acima o seguinte:\nprint(type(varInt)) print(type(varFloat)) print(type(varStr)) print(type(varBool)) a saída será:\n\u0026lt;class 'int'\u0026gt; \u0026lt;class 'float'\u0026gt; \u0026lt;class 'str'\u0026gt; \u0026lt;class 'bool'\u0026gt; Mais de uma variável pode ser criada na mesma linha. Exemplo:\nx, y, z = 1, 2, 3 w = y = k = 1 Imprimindo variáveis # Para imprimir os valores das variáveis, utilizamos a função print() das seguintes formas:\nvarInt = 10 varStr = \u0026#34;texto\u0026#34; # Imprimindo apenas a variável print(varInt) # Utilizando vírgula para adicionar ao texto variáveis que não são do tipo str. print(\u0026#34;varInt = \u0026#34;, varInt) # Utilizamos sinal de adição ou vírgula para variáveis str print(\u0026#34;varStr = \u0026#34;+ varStr) # Podemos adicionar variáveis em diferentes posições do texto print(\u0026#34;varInt = \u0026#34;, varInt, \u0026#34;e varStr = \u0026#34;, varStr) A saída será:\n10 varInt = 10 varStr = texto varInt = 10 e varStr = texto Convertendo tipos de variáveis # Podemos utilizar as funções int(), float(), e str() para converter variáveis para os tipos int, float e str, respectivamente. Por exemplo:\nx = 10 # tipo int y = 12.5 # tipo float z = \u0026#34;20\u0026#34; # tipo str var_1 = int(z) var_2 = float(x) var_3 = str(y) print(\u0026#34;var_1 = \u0026#34;, var_1, \u0026#34; tipo = \u0026#34;, type(var_1)) print(\u0026#34;var_2 = \u0026#34;, var_2, \u0026#34; tipo = \u0026#34;, type(var_2)) print(\u0026#34;var_3 = \u0026#34;, var_3, \u0026#34; tipo = \u0026#34;, type(var_3)) A saída será:\nvar_1 = 20 tipo = \u0026lt;class 'int'\u0026gt; var_2 = 10.0 tipo = \u0026lt;class 'float'\u0026gt; var_3 = 12.5 tipo = \u0026lt;class 'str'\u0026gt; Lendo valores para as variáveis # Para ler valores digitados no teclado, podemos utilizar a função input(). A função recebe um texto como entrada para ser exibido na tela e aguarda o valor de entrada. Exemplos:\nvar_1 = input(\u0026#34;Digite um valor:\u0026#34;) var_2 = int(input(\u0026#34;Digite um valor:\u0026#34;)) print(\u0026#34;var_1 = \u0026#34;, var_1, \u0026#34; tipo = \u0026#34;, type(var_1)) print(\u0026#34;var_2 = \u0026#34;, var_2, \u0026#34; tipo = \u0026#34;, type(var_2)) A função retorna uma variável do tipo str, dessa forma, precisamos fazer a conversão de tipos para atribuirmos o valor digitado a outros tipos de variável. No exemplo, caso o usuário digite \u0026ldquo;10\u0026rdquo; e \u0026ldquo;10\u0026rdquo;, a saída será:\nvar_1 = 10 tipo = \u0026lt;class 'str'\u0026gt; var_2 = 10 tipo = \u0026lt;class 'int'\u0026gt; Operadores aritméticos # Os operadores aritméticos são:\nOperador Descrição + adição - subtração * multiplicação / divisão com resultado real // divisão com resultado inteiro % resto da divisão ** exponenciação Exemplos:\nx = 10 y = 20 print(\u0026#34;Adição: \u0026#34;, x+y ) print(\u0026#34;Subtração: \u0026#34;, x-y ) print(\u0026#34;Multiplicação: \u0026#34;, x*y ) print(\u0026#34;Divisão real: \u0026#34;, x/y ) print(\u0026#34;Divisão inteiro: \u0026#34;, x//y ) print(\u0026#34;Resto da divisão: \u0026#34;, x%y ) print(\u0026#34;Exponenciação: \u0026#34;, x**y ) # leia-se: x elevado a y A saída será:\nAdição: 30 Subtração: -10 Multiplicação: 200 Divisão real: 0.5 Divisão inteiro: 0 Resto da divisão: 10 Exponenciação: 100000000000000000000 Exemplos de expressões com os operadores:\nx = x + 2 x += 2 # equivale a x = x + 2 x *= 2 # equivale a x = x * 2 # Podemos utilizar parênteses para definir precedências x = (x - 10) * x Operadores relacionais # Os operadores relacionais são:\nOperador Descrição \u0026gt; maior que \u0026lt; menor que \u0026gt;= maior ou igual \u0026lt;= menor ou igual == igual a != diferente de As expressões relacionais retornam o valores boleanos True ou False. Exemplos:\nx = 1 y = 2 z = x \u0026lt; y w = x == y print(z) print(w) A saída será:\nTrue False Operadores lógicos # Os operadores lógicos em python são bem intuitívos. São as palavras and, or, e not.\nExemplos de expressões com operadores lógicos:\nx, y, z = 1, 2, 3 w = (x \u0026lt; y) and (x \u0026lt; z); print(w) w = (x \u0026gt;= y) or (x \u0026lt; z); print(w) w = not(x == y); print(w) A saída será:\nTrue True True Comando condicional: if-else # A sintaxes do comando condicional em python são:\n# Sintaxe 1: IF if (condição): instruções_com_indentação # Sintaxe 2: o par IF-ELSE if (condição): instruções_com_indentação else: instruções_com_identação # Sintaxe 3: utilizando ELIF para aninhar várias condições if (condição_1): instruções_com_indentação elif (condição_2): instruções_com_indentação elif (condição_3): instruções_com_indentação ... elif (condição_n): instruções_com_indentação else: instruções_com_indentação Exemplos de código:\n#if-else x = int(input(\u0026#34;Digite um decimal:\u0026#34;)) if (x \u0026lt; 5): print(\u0026#34;x maior que 5\u0026#34;) else: print(\u0026#34;x menor que 5\u0026#34;) #if-elif x = int(input(\u0026#34;Digite um decimal:\u0026#34;)) if (x \u0026lt; 5): print(\u0026#34;x é maior que 5\u0026#34;) elif (x \u0026gt; 5): print(\u0026#34;x é menor que 5\u0026#34;) else: print(\u0026#34;x é igual a 5\u0026#34;) Comando de repetição: for # Para aprendermos a sintaxe do for em Python, vamos entender primeiro a função range():\nA função range() é utilizada para a geração de uma sequência de números inteiros. A sintaxe é:\nrange(valor_inicial, parada, incremento) A função gera inteiros a partir de valor_inicial (incluso) até o valor definido em parada (não incluso). Caso valor_inicial seja omitido, inicia-se a partir do zero. O incremento é opcional, e pode assumir valores positivos, ou negativos para decrementos.\nExemplos:\nrange(5) # Retorna os números 0,1,2,3,5 range(1,5) # Retorna os números 1,2,3,4 range(0,10,2) # Retorna os números 0, 2, 4, 6, 8 range(-10,10,2) # Retorna os números -10, -8, -6, -4, -2, 0, 2, 4, 6, 8 Na verdade, a função retorna uma variável do tipo range, um dos tipos de sequências de Python. Vejamos:\nx = range(5) prinf(type(x)) A saída será: \u0026lt;class \u0026lsquo;range\u0026rsquo;\u0026gt;\nPodemos utilizamos a variável do tipo range na estrutura do for. A sintaxe é:\nfor indice in variável_de_sequência: instruções_com_indentação Exemplos:\n# Exemplo 1 x = range(5) for i in x: print(i) # Exemplo 2 for j in range(5): print(j) Comando de repetição: while # A sintaxe do comando while em Python é:\nwhile (condição): instruções_com_indentação Exemplo:\nx = 0 while (x \u0026lt; 10): print(x) x+=1 Variáveis de tipos de sequências # Além do tipo range visto em conjunto com o comando for, Python define listas e tuplas para agruparmos elementos em sequência. Vejamos a seguir.\nListas # Uma lista é um conjunto de elementos ordenados. A sintaxe é:\nnome = [elemento1, elemento2, ..., elementoN] Características de listas:\nOs elementos possuem ordem fixa. O índice inicial da lista é o zero. Podem conter elementos de tipos diferentes. Podem conter elementos reptidos. Elementos podem ser mofificados ou adicionados/removidos da lista. Exemplos:\nx = [] # lista vazia x = [1, 2] # lista de inteiros x = [\u0026#34;text1\u0026#34;, \u0026#34;text2\u0026#34;, \u0026#34;text3\u0026#34;] # lista de strings z = [1, \u0026#34;text1\u0026#34;, 2, \u0026#34;text2\u0026#34;] # lista de inteiros e strings Acessamos os elementos pelo índice:\nx = [1,2,3] x[0] = 10 # altera o valor do primeiro elemento para 10 x[1] += 9 # altera o valor do segundo elemento para 11 Métodos úteis:\nx = [1,2,3,4,5,6,7] # Append(elemento) - adiciona elemento ao final da lista x.append(8) # x = [1,2,3,4,5,6,7,8] # Insert(indice, elemento) - insere um elemento no índice indicado x.insert(2, 3) # x = [1,2,3,3,4,5,6,7,8] # Pop(indice) - remove elemento no índice indicado x.pop(1) # x = [1,3,3,4,5,6,7,8] # Remove(elemento) - Remove a primeira instância do conteúdo fornecido. x.remove(3) # x = [1,3,4,5,6,7,8] # Count(elemento) - Retorna o número de vezes elemento aparece na lista n = x.count(2) # n = 0. # Len(lista) - Retorna o número de elementos da lista n = len(x) # n = 7 Podemos iterar uma lista na estrutura for, por exemplo:\nx = [1,2,3,4,5,6,7] for i in x: print(i) Podemos ter listas de listas, gerando estruturas com mais de uma dimensão, por exemplo:\n# Uma lista de duas dimensões, como uma matriz lista = [ [1, 2, 3], [4, 5, 6] ] print(lista[0]) # Imprime: [0, 1, 2] print(lista[0][0]) # Imprime: 1 Tuplas # Tuplas são conjuntos de elementos ordenados, mas que não podem ser alterados. A sintaxe é:\nnome = (elemento1, elemento2, ..., elementoN) Características de tuplas\nOs elementos possuem ordem fixa. O índice inicial é o zero. Podem conter elementos de tipos diferentes. Podem conter elementos reptidos. Elementos NÃO podem ser mofificados ou adicionados/removidos da lista. O parênteses é opcional. Exemplos:\nx = (1, 2) # tupla de inteiros x = \u0026#34;text1\u0026#34;, \u0026#34;text2\u0026#34;, \u0026#34;text3\u0026#34; # tupla de strings z = (1, \u0026#34;text1\u0026#34;, 2, \u0026#34;text2\u0026#34;) # tupla de inteiros e strings Funções # A sintaxe para criação de funções em Python é:\ndef nome_da_função( lista_de_parametros ): instruções_indentadas return valor Lista de parametros e valor de retorno são opcionais. Vejamos exemplos:\ndef funcao_1(): print(\u0026#34;Esta é uma função em Python.\u0026#34;) def funcao_2(a, b): return a + b funcao_1() # chamada da função_1 c = funcao_2(1, 2) # chamada da funcao_2 com passagem de valores a, b = 1, 2 c = funcao_2(a, b) # chamada da funcao_2 com passagem de variáveis Podemos declarar funções com número variável de parâmetros de entrada, para isso, declaramos a função com um parâmetro de entrada, e acrescentamos o símbolo * ao seu nome. Neste caso, a linguagem trata o parâmetro como uma tupla. Exemplo:\ndef funcao( *x ): print(type(x)) # Imprime: \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; for i in x: print(i) # Exemplos de chamada da funcao funcao() funcao(1,2,3) funcao(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;) Bibliotecas # Bibliotecas em Python são conjuntos de módulos e pacotes que contêm códigos prontos para realizar diversas tarefas, facilitando o desenvolvimento de programas. Em essência, uma biblioteca é uma coleção de funções que você pode importar para o seu código para evitar ter que escrever tudo do zero.\nAs bibliotecas ajudam a economizar tempo e esforço, fornecendo funcionalidades específicas, como manipulação de arquivos, cálculos matemáticos, criação de gráficos, aprendizado de máquina, entre outras.\nPara usar uma biblioteca, você precisa importá-la no seu código com o comando import, seguido do nome da biblioteca. Normalmente, utilizamos o comando import no início dos arquivos.\nA seguir, veremos alguns exemplos de bibliotecas em Python:\nMath # A biblioteca math do Python fornece funções matemáticas básicas e avançadas, permitindo realizar cálculos científicos com precisão. Ela inclui funções para trigonometria, logaritmos, exponenciais, números fatoriais, arredondamento, e muito mais. Além disso, a biblioteca math fornece constantes matemáticas úteis, como pi (π) e o número de Euler (e).\nMath é uma bilbioteca externa e precisa ser instalada antes de ser utilizada.\nSegue exemplo de utilização:\nimport math raiz = math.sqrt(16) # Calcula a raiz quadrada de 16 print(\u0026#34;Raiz quadrada de 16:\u0026#34;, raiz) A tabela abaixo contém símbolos comumente utilizados:\nSímbolo Função math Descrição π (pi) math.pi Constante pi (3.14159\u0026hellip;) e math.e Número de Euler e (2.71828\u0026hellip;) eˆx math.exp(x) Retorna e elevado a x, onde e é o número de Euler √ (raiz) math.sqrt(x) Raiz quadrada de x x^y math.pow(x, y) x elevado a y log(x) math.log(x) Logaritmo natural de x (base e) log10(x) math.log10(x) Logaritmo base 10 de x sin(x) math.sin(x) Seno de x (em radianos) cos(x) math.cos(x) Cosseno de x (em radianos) tan(x) math.tan(x) Tangente de x (em radianos) graus → rad math.radians(x) Converte graus para radianos rad → graus math.degrees(x) Converte radianos para graus As funções da biblioteca math podem ser utilizadas para compor expressões matemáticas. Por exemplo, considere a fórmula do crescimento exponencial contínuo, frequentemente usada em áreas como economia, biologia e física:\nA = P * e^(r * t) Um código em Python que a descreve é:\nimport math # Parâmetros P = 1000 # Valor inicial r = 0.05 # Taxa de crescimento (5%) t = 10 # Tempo em anos # Fórmula do crescimento exponencial A = P * math.exp(r * t) print(\u0026#34;O valor final após\u0026#34;, t, \u0026#34;anos é: R$ \u0026#34;, A) "},{"id":7,"href":"/docs/04-c++/","title":"CURSO: Informática com C++","section":"Docs","content":""},{"id":8,"href":"/docs/temp/expand/","title":"Expand","section":"temp","content":" Expand # Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample # Default # {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Expand ↕ Markdown content # Lorem markdownum insigne\u0026hellip; With Custom Label # {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Custom Label ... Markdown content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia. "},{"id":9,"href":"/docs/temp/hints/","title":"Hints","section":"temp","content":" Hints # Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example # Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa "},{"id":10,"href":"/docs/","title":"Docs","section":"Introduction","content":""}]